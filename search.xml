<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>.NET中的十进制浮点数</title>
    <url>/2021/01/14/Decimal-Floating-Point/</url>
    <content><![CDATA[<p>在我关于二进制浮点类型的文章(<a href="https://csharpindepth.com/articles/FloatingPoint">原文</a> <a href="/2021/01/13/Binary-Floating-Point/">译文</a>)中，我简单地提到了<code>System.Decimal</code>（或者指C#中<code>decimal</code>）类型。本文给出了关于该类型的更多细节，包括它的表示方法以及它与更常见的二进制浮点类型之间的一些区别。本文从这里开始，之后所说的<code>decimal</code>就是指<code>System.Decimal</code>，同理，提到<code>float</code>和<code>double</code>就是指.NET的类型<code>System.Single</code>和<code>System.Double</code>。为了让文章更易阅读，我也会把它们的名字改成正常字体。（<em>注释：译文里还是会区分一下的</em>）<span id="more"></span></p>
<h2 id="什么是decimal类型"><a class="markdownIt-Anchor" href="#什么是decimal类型"></a> 什么是<code>decimal</code>类型？</h2>
<p><code>decimal</code>类型就是另一种浮点数——但不同于<code>float</code>和<code>double</code>，它的基数是10。如果你还没看过上文的文章链接，现在先去看看吧——本文不再提及浮点数的基础知识。</p>
<p><code>decimal</code>类型和其余浮点数有相同的组成：尾数、指数和符号位。通常来说，<code>decimal</code>类型符号位也只有1位，但是有96位尾数和5位指数。但是，并不是所有的指数组合都有效。只有0-28的数值才有效，而且它们实际上都是负数：数值表示为<em>符号位 * 尾数 / 10<sup>指数</sup></em>。这意味着该类型的最大值和最小值是+/-(2<sup>96</sup>-1)，最小非零数是10<sup>-28</sup>。</p>
<p>指数受限的原因是因为尾数位只能存储28或29位小数（取决于具体的数值）。实际上，假如你有28位数字，你就可以设置任何你想要的值，可以将小数点放在第一位数字的左边到最后一位右边的任意位置。（会有一些数字，你可以把第29位数字放在其余数字的左边，但你不可能获取所有29位数字的组合，因此就有了此限制）。</p>
<h2 id="decimal如何存储"><a class="markdownIt-Anchor" href="#decimal如何存储"></a> <code>decimal</code>如何存储？</h2>
<p><code>decimal</code>以128位存储，尽管严格来说只有102位是必须的。我们可以简单地把<code>decimal</code>看作是4个32位整型数，其中三个用来表示尾数，其余一个表示符号位和指数。最后一位整数的最高位是符号位（通常来说，负数会设置为1）然后16-23位（高16位字的低位）是指数位。其他位都要清0，。这种表示法是<code>decimal.GetBits(decimal)</code>给出的，它会返回一个含有4个int数的数组。</p>
<h2 id="decimal格式化"><a class="markdownIt-Anchor" href="#decimal格式化"></a> <code>decimal</code>格式化</h2>
<p>与<code>float</code>和<code>double</code>不同，在.NET中，当<code>decimal</code>被转换为字符串时，其默认行为是给出精准的值。这意味着<code>decimal</code>没有类似于二进制浮点数文章提到的<code>DoubleConverter</code>的方法。当然，你可以对其精度进行限制。</p>
<h2 id="保留0位"><a class="markdownIt-Anchor" href="#保留0位"></a> 保留0位</h2>
<p><a href="http://xn--3ds.NET">在.NET</a> 1.0和1.1之间，<code>decimal</code>类型发生了微妙的变化。看看下面这个简单的程序：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decimal</span> d = <span class="number">1.00</span>m;</span><br><span class="line">        Console.WriteLine (d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我第一次运行上面的程序（或类似的程序）时，我以为它只输出1（<a href="http://xn--3dsp36ahp5a.NET">这是在.NET</a> 1.0上的结果）——但事实上，输出是1.00。<code>decimal</code>类型不会自己归一化——它会记录自己有多少个小数位（通过尽可能地保存指数），在格式化时，零可能被算作一个重要的小数位。我不知道当两个不同的小数进行相乘、相除、相加等一系列操作时，是如何选择指数的（在有选择的情况下），你可以跑跑下面的程序，会发现很有意思：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decimal</span> d = <span class="number">0.00000000000010000</span>m;</span><br><span class="line">        <span class="keyword">while</span> (d != <span class="number">0</span>m)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (d);</span><br><span class="line">            d = d/<span class="number">5</span>m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.00000000000010000</span><br><span class="line">0.00000000000002000</span><br><span class="line">0.00000000000000400</span><br><span class="line">0.00000000000000080</span><br><span class="line">0.00000000000000016</span><br><span class="line">0.000000000000000032</span><br><span class="line">0.0000000000000000064</span><br><span class="line">0.00000000000000000128</span><br><span class="line">0.000000000000000000256</span><br><span class="line">0.0000000000000000000512</span><br><span class="line">0.00000000000000000001024</span><br><span class="line">0.000000000000000000002048</span><br><span class="line">0.0000000000000000000004096</span><br><span class="line">0.00000000000000000000008192</span><br><span class="line">0.000000000000000000000016384</span><br><span class="line">0.0000000000000000000000032768</span><br><span class="line">0.0000000000000000000000006554</span><br><span class="line">0.0000000000000000000000001311</span><br><span class="line">0.0000000000000000000000000262</span><br><span class="line">0.0000000000000000000000000052</span><br><span class="line">0.000000000000000000000000001</span><br><span class="line">0.0000000000000000000000000002</span><br></pre></td></tr></table></figure>
<h2 id="一切都是数字"><a class="markdownIt-Anchor" href="#一切都是数字"></a> 一切都是数字</h2>
<p><code>decimal</code>类型<code>infinity</code>和<code>NaN（not a number）</code>的概念，尽管上面的例子说明同一个数字会有不同的表现形式（例如1，1.0，1.00），但通常<code>==</code>运算符就可以处理这些问题，例如<code>1.0==1.00</code>会返回True。</p>
<h2 id="精准度"><a class="markdownIt-Anchor" href="#精准度"></a> 精准度</h2>
<p>虽然<code>decimal</code>类型的潜在指数范围比较小，但它的精度比任何.NET中的内置二进制浮点数都要高。而且，在二进制浮点数中因为原始操作数精度不够而造成的奇怪结果，在<code>decimal</code>中并不会存在，这是因为许多操作数在源码中就是表示为十进制（decimals）的。然而，这并不意味着所有的操作都会变得精准：例如，三分之一仍然无法准确表示。其潜在的问题和二进制浮点的问题是一样的。但是，大多数时候，类似货币这样的数值，仍然要选择使用<code>decimal</code>类型，这会使操作变得简单，还能保持精度（例如，添加一个指定为百分比的税金，仍可以保持数字的准确性，前提是这些数字在合理的范围内）。只需要注意哪些操作会导致不精确，哪些不会。</p>
<p>有一个十分宽泛的经验，如果你的结果用字符串表示后非常长（即28/29位的大部分数字都是非零的）那么就有可能在过程中出现了有误差的情况：如果数字精确，那么使用<code>decimal</code>类型表示的数字不会有那么多位有效数字。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>大多数商业应用应当使用<code>decimal</code>而不是<code>float</code>或<code>double</code>。我的经验法则是，货币等人造值通常用<code>decimal</code>来表示比较好：例如，正好是1.15美元的概念是完全合理的。对于来自自然界的值，如长度和重量，二进制浮点类型更有意义。即使理论上有 “正好是1.15米”，但在现实中也不会出现：你肯定永远无法测量出精准的长度，在原子水平上它们甚至都不太可能存在。我们习惯于其中存在一些误差。</p>
<p>使用<code>decimal</code>浮点运算是需要付出代价的，但我认为这不太可能成为大多数开发者的瓶颈。一如既往，先写出最合适的（可读的）代码，然后再继续分析你的性能。通常情况下，缓慢得到正确的答案总比快速得到错误的答案要好得多——尤其是在涉及到钱的时候…</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/Decimal">Decimal floating point in .NET</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>浮点数</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制浮点数和.NET</title>
    <url>/2021/01/13/Binary-Floating-Point/</url>
    <content><![CDATA[<p>当在.NET中碰到一些运算结果“出错”的情况时，很多人都会感到惊讶。但这并不是.NET所特有的——大多数语言/平台都使用所谓的 &quot;浮点 &quot;算术来表示非整数。这本身是没有问题的，但是你需要对其表面下的本质有所了解，才不至于对一些结果产生疑惑。</p>
<p>需要说明的是，我不是这方面的专家。自撰写本文以来，我发现了另一篇——由真正的专家Jeffrey Sax撰写的文章。我强烈推荐各位也去看看他在浮点数方面的<a href="http://www.extremeoptimization.com/resources/Articles/FPDotNetConceptsAndFormats.aspx">文章</a>。 <span id="more"></span></p>
<h2 id="什么是浮点数"><a class="markdownIt-Anchor" href="#什么是浮点数"></a> 什么是浮点数？</h2>
<p>计算机总会需要某种方式来表示数据，最终这些表示方式总会归结为二进制（0和1）。整型数其实很容易表示（对负数会有适当的约定，并且有明确的范围，能够知道开始表示的范围有多大）但是非整型数就有点难办了。无论你想出什么办法，总会出现一些问题。比如说，拿我们正常写数字的十进制来说：它（本身）无法表示三分之一。末尾会反复出现3。无论你想出什么办法，你总会在一些数字上遇到同样的问题——尤其是无理数（无法用分数表示的数）比如数学常量<em>pi</em>和<em>e</em>，它们总会带来问题。</p>
<p>你可以用两个整数准确地存储所有的有理数，可以通过第一个数除以第二个数表示——但是即使是很&quot;简单&quot;的操作，整数也会迅速地增长，而且像平方根这样的操作很容易产生无理数。还有其他各种方案都会带来问题，但大多数系统会以某种形式使用<em>浮点数</em>。这个想法大致来说就是，通过一个带有比例的整数（<em>尾数mantissa</em>）和另一个表示比例的数（<em>指数exponent</em>）（用来指出“小数点在哪”），来表示一个数。（<em>个人理解：应该就是科学计数法</em>）例如，34.5在&quot;十进制浮点数&quot;中可以表示为：尾数为3.45，指数为1，而3450可以与之有相同的尾数，但是指数是3（34.5就是3.45x10<sup>1</sup>，3450就是3.45x10<sup>3</sup>）。这个例子为了简化使用的是十进制，但最常见的浮点格式是二进制。例如，二进制尾数是1.1，指数是-1，就表示十进制的0.75（二进制1.1==十进制1.5，指数为-1表示“除以2”，就像十进制指数-1表示“除以10”）。</p>
<p>有一点很重要，你需要搞清楚，就像你无法在十进制中（有限）精准的表示三分之一一样，有很多数字在十进制中看起来很简单，但在二进制中却会很长或者是无限的。这意味着（例如）一个二进制浮点变量无法精准表示十进制的0.1。假设你有这样一段代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> x = <span class="number">0.1</span>d;</span><br></pre></td></tr></table></figure>
<p>变量x实际上存储的是最接近0.1d的可用double类型数。一旦你能理清这一点，就会明白为什么有些计算似乎是 “错误的”。如果你需要计算三分之一加三分之一，但只能用小数点后三位表示三分之一，那你就会得到“错误”的答案：最接近三分之一的是0.333，两者相加是0.666，而不是0.667（更接近三分之二的准确值）。一个二进制浮点数的例子是3.65d+0.05d !=3.7d (虽然在某些情况下可能显示为3.7)。</p>
<h2 id="net中的浮点类型有哪些"><a class="markdownIt-Anchor" href="#net中的浮点类型有哪些"></a> .NET中的浮点类型有哪些？</h2>
<p>C#标准只把<code>double</code>和<code>float</code>列为可用的浮点数（<code>System.Double</code>和<code>System.Single</code>的C#简写），但<code>decimal</code>类型（<code>System.Decimal</code>的简写）其实也是一种浮点数——只不过它是十进制浮点数，指数的范围很有意思。<code>decimal</code>类型在另一篇文章(<a href="https://csharpindepth.com/articles/Decimal">原文</a> <a href="/2021/01/13/Decimal-Floating-Point/">译文</a>)中已经介绍过了，所以这篇文章就不多说了，我们会集中于<code>double</code>和<code>float</code>类型。这两种类型都是二进制浮点类型，符合IEEE 754标准（一个定义各种浮点类型的标准）。<code>float</code>类型是32位类型（1位符号位，23位尾数和8位指数），<code>double</code>类型是64位类型（1位符号位，53位尾数和11位指数）。</p>
<h2 id="结果并非所望岂不是很糟糕"><a class="markdownIt-Anchor" href="#结果并非所望岂不是很糟糕"></a> 结果并非所望，岂不是很糟糕？</h2>
<p>嗯，这要看具体情况。如果你正在编写一个财务相关应用，你可能有着非常严格的错误处理方式，而且金额也要直观地表示为十进制——这种情况下，<code>decimal</code>类型要比<code>float</code>和<code>double</code>更合适。然而，如果你正在编写一个科学类应用，那么与十进制表示法的联系可能就会比较弱，而且可能一开始你处理的数据就没有那么精准（一块钱就是一块钱，但如果你测量出的长度是一米，那可能一开始就会存在误差）。</p>
<h2 id="浮点数的比较"><a class="markdownIt-Anchor" href="#浮点数的比较"></a> 浮点数的比较</h2>
<p>总体概括得出的结论就是，你应该非常非常少地去直接比较浮点数是否相等。通常用大于等于或小于等于来比较是可行的，但当你需要判断相等时，你就该想一想你实际想要的是否几乎相等：一个数字是否与另一个数字几乎相等。一个简单的方法就是用一个数减去另一个，再用<code>Math.Abs</code>算出差值的绝对值，然后判断这个差值是否低于一定的误差。（个人理解：所谓“几乎相等”即判断两个浮点数之间的误差在某个值以内时就认为两者相等）</p>
<p>不过也有一些情况特别病态，这都是JIT优化造成的。请看下面的代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">float</span> f;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f = Sum (<span class="number">0.1f</span>, <span class="number">0.2f</span>);</span><br><span class="line">        <span class="built_in">float</span> g = Sum (<span class="number">0.1f</span>, <span class="number">0.2f</span>);</span><br><span class="line">        Console.WriteLine (f==g);</span><br><span class="line"><span class="comment">//        g = g+1;</span></span><br><span class="line"><span class="comment">// Or...  Console.WriteLine(g);</span></span><br><span class="line"><span class="comment">// Or...  GC.KeepAlive(g);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Sum</span> (<span class="params"><span class="built_in">float</span> f1, <span class="built_in">float</span> f2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f1+f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该总是输出True对吧？不幸的是，错啦！当在调试（debug）模式下运行时，JIT无法像正常情况下那样进行大量优化，就会显示True。当正常运行时，JIT能够存储的数值远比float能表示的数值更精准，它可以使用x86 80位表示法来表示求和的值、返回值和本地变量。更多细节请参见ECMA CLI规范，第1部分，12.1.3节。将上面代码的注释去除，<em>可能</em>会是JIT的行为保守一些，从而导致结果为True。然而，这取决于具体的实现、CLR版本、处理器等–这都不是你应该依赖的东西。（事实上，在某些环境下，只有部分被注释的行会对结果造成影响。）这也是另一个避免相等判断的原因，哪怕你真的确信结果是相等的。</p>
<h2 id="net如何格式化浮点数"><a class="markdownIt-Anchor" href="#net如何格式化浮点数"></a> .NET如何格式化浮点数？</h2>
<p>在.NET中，没有内置的方法可以查看浮点数的精确小数，但是你仍然可以通过一些手段做到。（参见本文底部的一些代码。）默认情况下，.NET将<code>double</code>类型格式化为小数点后15位，<code>float</code>类型格式化为小数点后7位（某些情况下，会使用科学计数法；更多信息请参见MSDN关于标准数字格式化字符串的页面）。如果你使用往返格式指定符（round-trip format specifier）（“r”），会将数字格式化为最短的形式，当再解析（到同一类型）时，将会返回原始的数字。如果你是以字符串的形式存储浮点数，而且精确的数值对你很重要，你一定要使用往返指定符，否则很可能会丢失数据。</p>
<p><em>个人理解：举个例子</em></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> doubleVal = <span class="number">0.354951324</span>d;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> doubleStr = doubleVal.ToString(<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> parseVal = <span class="built_in">double</span>.Parse(doubleStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三个输出应该完全相同</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;double value: <span class="subst">&#123;doubleVal&#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;after format: <span class="subst">&#123;doubleStr&#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;parse value: <span class="subst">&#123;parseVal&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//doubleVal应当与parseVal表示的是同一个数，且精度不会丢失</span></span><br><span class="line">        <span class="comment">//即所谓的通过往返格式指定（“r”）进行的格式化和解析，不会丢失精度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点数在内存中到底是什么样的"><a class="markdownIt-Anchor" href="#浮点数在内存中到底是什么样的"></a> 浮点数在内存中到底是什么样的？</h2>
<p>就像上面说的，一个浮点数基本上有一个符号位、一个指数和一个尾数。这三者都是整数，它们的组合可以明确地表示出一个数字。浮点数有各种类别：<code>normalised</code>、<code>subnormal</code>、<code>infinity</code>和<code>not a number（NaN）</code>。大多数数字都是归一化的（<code>normalised</code>），也就是二进制尾数的第一位都被假定为1，这就意味着实际上并不用存它。例如二进制数1.01101可以表示为.01101——第一位的1假定是存在的，如果首位是0（即0.01101），那么就会使用不同的指数去表示。这种技术只有当你使用的指数在适当范围内时才会有效。不在该范围内的数（非常非常小的数）称为<code>subnorma</code>l，不假定前导位。&quot;<code>not a number&quot;（NaN）</code>&quot;值是指像0除以0这样的结果。NaN有各种不同的类别，也有一些奇怪的行为。<code>subnormal</code>数有时也被称为<code>denormalised</code>数。（<em>个人理解：这部分的概念：<code>normalised</code>和<code>subnormal</code>可以翻译为规格化数和非规格化数，但怕造成歧义就保留了原文，建议看看文章开头链接里的那篇<a href="http://www.extremeoptimization.com/resources/Articles/FPDotNetConceptsAndFormats.aspx">文章</a>，这几个概念介绍的很详细</em>）</p>
<p>符号位、指数和尾数在字符位级别的实际表示方法是，每一个符号位、指数和尾数都是一个无符号整数，按照符号位、指数和尾数的顺序存储。&quot;真实 &quot;的指数是有偏差的——例如，在<code>double</code>的情况下，指数偏移了1023位，所以存储的指数如果是1026，实际计算时就代表3。下表以<code>double</code>为例，说明了符号位、指数和尾数各组合的含义。同样的原理也适用于<code>float</code>，只是数值略有不同（如偏移量）。请注意指数值在表中是&quot;存储指数位&quot;这一列，是偏移之前的值（这就是为啥偏移量1023显示在了&quot;数值&quot;这一栏）。</p>
<table>
<thead>
<tr>
<th>符号位（s，1位）</th>
<th>存储指数位（e，11位）</th>
<th>尾数（m，52位）</th>
<th>数值类型</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意数</td>
<td>非零数</td>
<td>任意数</td>
<td>Normal</td>
<td>(-1)<sup>5</sup> x 1.m(二进制表示) x 2<sup>e-1023</sup></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>Zero</td>
<td>+0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>Zero</td>
<td>+0</td>
</tr>
<tr>
<td>0</td>
<td>2047</td>
<td>0</td>
<td>Infinity</td>
<td>正无穷（Positive infinity）</td>
</tr>
<tr>
<td>1</td>
<td>2047</td>
<td>0</td>
<td>Infinity</td>
<td>负无穷（Negative infinity）</td>
</tr>
<tr>
<td>0</td>
<td>2047</td>
<td>非零数</td>
<td>NaN</td>
<td>n/a</td>
</tr>
</tbody>
</table>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<p>考虑以下64位二进制数：<br />
0 10000000100 0111001101101101001001001000010101110011000100100011</p>
<p>作为一个<code>double</code>类型数，将其拆分：</p>
<ul>
<li>符号位：0</li>
<li>指数：10000000100（二进制）== 1028（十进制）</li>
<li>尾数：0111001101101101001001001000010101110011000100100011</li>
</ul>
<p>因此，这是一个正常（normal，对应表中第一行类型）的数值<br />
(-1)<sup>0</sup> x 1.0111001101101101001001001000010101110011000100100011 (二进制) x 2<sup>1028-1023</sup><br />
可以简单的表示为<br />
1.0111001101101101001001001000010101110011000100100011 (二进制) x 2<sup>5</sup><br />
或者<br />
101110.01101101101001001001000010101110011000100100011</p>
<p>十进制表示就是：46.42829231507700882275457843206822872161865234375，但在.NET中会默认显示为46.428292315077或者使用往返格式指定符（round-trip format specifier）格式化后显示为46.428292315077009。</p>
<h2 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h2>
<p><a href="https://jonskeet.uk/csharp/DoubleConverter.cs">DoubleConverter.cs</a>：这是一个相当简单的类，它可以将一个<code>double</code>类型转化为精确的十进制字符串。请注意，虽然十进制的有限小数不一定有有限的二进制表示，但是所有有限的二进制小数都可以通过有限的十进制小数表示（因为2是10的倍数）。该类的使用非常简单——只需调用<code>DoubleConverter.ToExactString(value)</code>，就会返回value的精确字符串表示。</p>
<h2 id="nans"><a class="markdownIt-Anchor" href="#nans"></a> NaNs</h2>
<p>NaNs是个奇怪的怪物。NaNs有两种类型——<em>signalling</em>和<em>quiet</em>，简称SNaN和QNaN。从位模式上看，QNaN会设置尾数的顶位，而SNaN却会清除顶位。QNaN用来表示一个数学运算结果是不确定的，而SNaN用来表示异常（运算无效，不仅仅是一个不确定的结果）。</p>
<p>关于NaNs，大多数人感到奇怪的是，它自身不相等。例如，<code>Double.NaN == Double.NaN</code>返回的是false。相反，你需要使用<code>Double.IsNaN</code>来判断一个值是否不是一个数字。幸好，大多人除了在这样的文章，很少会再碰到NaNs。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>只要你了解了二进制浮点数的原理，使用它就完全没问题，不要指望你程序中的值完全是十进制的，也不要指望涉及二进制浮点数的计算一定能得到精确的结果。即使两个数字都以你使用的正确类型被表示了出来，涉及两数的运算结果也不一定能正确表示。这种情况在除法中最容易出现（例如，尽管1和10都是可以被确切表示的，但1/10却无法被确切表示），这种情况可能发生在任何操作中——即使是看似无害的操作，如加法和减法。</p>
<p>如果你特别想要精确的十进制数，可以考虑使用<code>decimal</code>类型来代替——但预计这样做会有性能问题。（其实可以很快地设计出一个测试方法，从而得出<code>double</code>类型的乘法运算速度比<code>decimal</code>类型的小数乘法运算速度快了40倍，不要太在意具体的数值，但这已经足够说明，在目前的硬件上，二进制浮点数运算一般是比十进制浮点数运算更快的。）</p>
<p>根据我的经验，大多数商务类型的应用中的数值，用十进制浮点数表示比用二进制浮点数表示更好。尤其是，几乎所有与钱有关的东西，用<code>decimal</code>来表示可能更合适。</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/FloatingPoint">Binary floating point and .NET</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>浮点数</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式在C#中的实现</title>
    <url>/2021/01/07/Implementing-the-Singleton-Pattern-in-C/</url>
    <content><![CDATA[<!-- # 目录
  - [介绍](#介绍)
  - [版本一&nbsp;-&nbsp;非线程安全](#版本一-非线程安全)
  - [版本二&nbsp;-&nbsp;简单的线程安全](#版本二-简单的线程安全)
  - [版本三&nbsp;-&nbsp;尝试使用双重锁保证线性安全](#版本三-尝试使用双重锁保证线性安全)
  - [版本四&nbsp;-&nbsp;不是典型的懒惰模式但线程安全没有用锁](#版本四-不是典型的懒惰模式但线程安全没有用锁)
  - [版本五&nbsp;-&nbsp;完全延迟加载实现](#版本五-完全延迟加载实现)
  - [版本六&nbsp;-&nbsp;使用\.NET4的Lazy<T>类型](#版本六-使用net4的lazyt类型)
  - [性能与延迟\（Laziness\）](#性能与延迟laziness)
  - [异常](#异常)
  - [结论](#结论) -->
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>单例模式是软件工程中最为人熟知的一种设计模式。本质上讲，单例就是一个类，这个类只允许创建一个自己的实例，并且通常会提供一个对该实例的简单访问。最常见的情况是，单例在实例化时不允许指定任何参数，否则的话，在第二次请求时，如果使用不同的参数，就会出现问题！（如果所有带有相同参数的请求都会访问相同的实例，那么工厂模式会比较合适）本文只涉及不需要参数的情况。通常情况下，对单例创建的要求是延迟（Lazy）创建-即在第一次需要之前不会创建实例。 <span id="more"></span></p>
<p>在C#中，有多种不同的方式来实现单例模式。我会按照由浅入深顺序介绍，从最常见的、非线程安全的版本开始，一直到完全延迟加载、线性安全、简单且高性能的版本。</p>
<p>然而，所有实现方式都有四个功能特点：</p>
<ul>
<li>一个单一的私有无参构造函数，以防止其他类对其进行实例化（违反了单例模式）。请注意，这还能防止子类继承-如果一个单例能够被子类化一次，那么肯定可以子类化两次，那么每个子类都可以创建一个实例，显然违反了单例模式。如果你需要一个基类的单例，在运行前并不知道确切的类型，那么可以使用工厂模式。</li>
<li>单例类是密封类（sealed），严格来说，由于上面一条的限制，这一点完全没必要，但这可能会帮助JIT进行优化。</li>
<li>一个静态变量，如果存在的话，他持有单例创建出的实例的引用。</li>
<li>一个静态方法，用于获取单例实例的引用，必要时，需要创建实例。<em>个人理解：实例存在则获取，不存在则创建</em></li>
</ul>
<p>请注意，所有实现方式都要使用静态公共属性<code>Instance</code>作为访问实例的途径。在任何情况下，该属性都应该可以很容易的转换为一个方法，而不会对线程安全或性能造成影响。</p>
<h2 id="版本一-非线程安全"><a class="markdownIt-Anchor" href="#版本一-非线程安全"></a> 版本一 - 非线程安全</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误的代码！不用使用！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前已经提过，上面的版本是非线程安全的。两个不同的线程有可能对 <code>if (instance == null)</code> 都判断为true，然后都创建了实例，这就违反了单例模式。请注意，其实在判断if表达式之前，实例可能就已经被创建了，但内存无法保证新创建的实例能被其他线程看到，除非有一道合适的内存壁垒（memory barrier）来保证这一点。<em>个人理解：所谓合适的内存壁垒应该是指线程锁-lock</em></p>
<h2 id="版本二-简单的线程安全"><a class="markdownIt-Anchor" href="#版本二-简单的线程安全"></a> 版本二 - 简单的线程安全</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> padlock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (padlock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方式是线程安全的。线程会取出共享对象的锁（lock），然后再去在创建实例前检查实例是否已经创建。这样就解决了内存壁垒（memory barrier）的问题（因为锁定操作确保了所有的读取操作在逻辑上都发生在获取锁之后，而解锁操作确保了所有的写入操作在逻辑上都发生在释放锁之前），并确保只有一个线程会创建一个实例（因为一次只能有一个线程进入这部分代码–当第二个线程进入的时候，第一个线程已经创建了实例，对if表达式的判断为false）。不幸的是，由于每次请求实例时都会有一个获取锁的过程，导致性能会受到影响。</p>
<p>请注意，我没有像某些版本的实现那样，锁定<code>typeof(Singleton)</code>，而是锁定了一个私有的静态变量。锁定一个其他类可以访问的对象（比如Type），有可能会出现性能问题，甚至是死锁（deadlocks）。我一般会偏爱这种风格–在可能的情况下，创建专门用于锁定的对象，只锁定该对象，或者为了特定的目的而锁定文件（document）（例如：用于等待/pulsing一个队列）。通常这样的对象应该是它所在类的私有对象。这样更易于编写线程安全的应用。</p>
<h2 id="版本三-尝试使用双重锁保证线性安全"><a class="markdownIt-Anchor" href="#版本三-尝试使用双重锁保证线性安全"></a> 版本三 - 尝试使用双重锁保证线性安全</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误的代码！不用使用！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> padlock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (padlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式试图在做到线程安全的同时不用每次都获取锁（lock）。不幸的是，这种模式有四个缺点：</p>
<ul>
<li>这在Java中不起作用。这或许很奇怪，但是如果你在Java中也需要用到单例的话，还是有必要了解一下，毕竟C#程序员也有可能是Java程序员。Java内存模型并不能保证新对象的引用在被分配给实例之前，构造函数就已经完成了。Java内存模型在1.5版本进行了重构，但是在这之后，如果没有易失性变量（volatile variable），双重检查锁还是会被破坏（和C#一样）。</li>
<li>在没有任何内存壁垒（线程锁）的情况下，它也打破了ECMA CLI规范。在 .NET 2.0的内存模型下（比ECMA规范更强） 有可能是安全的，但我宁愿依赖那些更强的语义，尤其是对安全性存在怀疑的情况下。让实例变量变得不稳定（volatile）可以使其正常运转，显式的内存壁垒调用也可以正常运行，尽管在后一种情况下，即使专家也无法统一到底需要什么样的壁垒。我倾向于避免出现专家都在争论对错的情况！</li>
<li>很容易出错。这种模式和上一种模式差不多–出现任何重大变化都有可能影响其性能或正确性。</li>
<li>它的性能还是不如之后的实现。</li>
</ul>
<h2 id="版本四-不是典型的懒惰模式但线程安全没有用锁"><a class="markdownIt-Anchor" href="#版本四-不是典型的懒惰模式但线程安全没有用锁"></a> 版本四 - 不是典型的懒惰模式但线程安全没有用锁</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过显示的静态构造函数告诉C#编译器</span></span><br><span class="line">    <span class="comment">// 不要将类型标记为beforfieldinit</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，这真的是极其简单–但为什么它是线性安全的？又是如何做到延迟处理（lazy）的呢？在C#中静态构造函数被指定为只有在类的实例被创建或静态成员被引用时才执行，并且每个AppDomain只执行一次。考虑到对类型的新构造无论如何都会执行，这将比之前的添加额外检查的例子执行的更快。不过，还是存在一些小缺点：</p>
<ul>
<li>它不像其他实现那么地延迟（lazy）。特别是，如果存在<code>Instance</code>以外的静态成员，那么对这些成员的第一次引用将会导致创建实例。</li>
<li>会有一种复杂的情况：一个静态构造函数调用了另一个静态构造函数，另一个又调用了第一个（<em>个人理解：两个静态构造函数相互调用</em>）。可以在.Net规范中（9.5.3节的partition Ⅱ）查看更多关于类型初始化器的细节–别担心，不会太难，但需要注意在循环中静态构造函数互相引用的后果。</li>
<li>只有当类型被特殊标记为<code>beforefieldinit</code>时，.Net才会保证类型初始器的延迟性（laziness）。不幸的是，C#编译器（至少在 .Net 1.1的运行时）会将所有没有静态构造函数的类型（即被标记为静态的构造函数）标记为<code>beforefieldinit</code>。我这里有一篇文章（<a href="https://csharpindepth.com/articles/BeforeFieldInit">原文</a> <a href="/2021/01/11/beforefieldinit/index.html">译文</a>），详细介绍了这个问题。另外请注意，这会对性能造成影响，这一点会在文末进行讨论。</li>
</ul>
<p>对于这个实现方式（也只有这个方式），可以采取一种快捷方式，就是直接把<code>instance</code>作为只读的公共静态变量，然后抛弃<code>Instance</code>属性。这样能使代码的基本骨架更小巧。但大多数人还是希望有一个属性，以便于后续添加进一步的操作，并且JIT内联很可能使性能相同。（注意，如果需要延迟性，静态构造函数还是需要的）</p>
<h2 id="版本五-完全延迟加载实现"><a class="markdownIt-Anchor" href="#版本五-完全延迟加载实现"></a> 版本五 - 完全延迟加载实现</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> Nested.instance; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Nested</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过显示的静态构造函数告诉C#编译器</span></span><br><span class="line">        <span class="comment">// 不要将类型标记为beforfieldinit</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">Nested</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式实例化是由嵌套类的静态成员首次引用触发的，只会发生在<code>Instance</code>调用中。这意味着实现了完全的延迟性，却保留了之前所有的性能优势。需要注意的是，虽然嵌套类可以访问包围类的私有成员，但反之则不行，因此需要将<code>instance</code>声明为internal。不过这不会引发其他问题，因为嵌套类本身是私有的。不过，为了让实例化延迟，代码会比较复杂。</p>
<h2 id="版本六-使用net4的lazyt类型"><a class="markdownIt-Anchor" href="#版本六-使用net4的lazyt类型"></a> 版本六 - 使用.NET4的Lazy<T>类型</h2>
<p>如果你使用的是 .Net 4（或更高版本），你可以使用 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1">System.Lazy<T></a> 类型让延迟（lazy）变得非常简单。你需要做的就是向调用Singleton构造函数的构造函数传递一个委托（delegate）–可以通过lambda表达式很容易地做到。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;Singleton&gt; lazy = <span class="keyword">new</span> Lazy&lt;Singleton&gt;(() =&gt; <span class="keyword">new</span> Singleton());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> lazy.Value; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这很简单，性能也不错。如果需要的话，你可以使用<a href="https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1.isvaluecreated">IsValueCreated</a>属性检查实例是否被创建。</p>
<p>上面的代码隐式使用了<code>LazyThreadSafetyMode.ExecutionAndPublication</code>作为<code>Lazy&lt;Singleton&gt;</code>的线程安全模式。你也可以根据自己的需求尝试其他模式。如果你的单例在一个相对频繁的循环中被引用，那么这样会是性能产生（相对）显著的差异。你需要决定是否需要完全延迟处理实例化，在类中的适当位置雅瑶记录这个决定。</p>
<h2 id="性能与延迟laziness"><a class="markdownIt-Anchor" href="#性能与延迟laziness"></a> 性能与延迟（Laziness）</h2>
<p>大多是情况下，实际上你并不需要完全的延迟处理–除非你在类初始化时做了一些特别耗时的操作，或者在别处做了一些有副作用的操作，否则不使用上文提到的显式静态构造函数也是可以的。这样可以提高性能，因为它允许JIT编译器进行一次简单的检查（例如在方法开始时），以确保类型已经被初始化，然后才开始使用它。</p>
<p>这一页之所以存在，很大程度上是大家自作聪明，想要想出一种双重锁检查的算法。有一个常见的误区，认为锁定（locking）是代价很大的操作。我有写过一个性能测试，它尝试用十亿种方式使用不同的变量在循环中获取单例。这样不是很科学，因为在现实中，你可能想知道，调用单例的方法在每次迭代中到底执行的有多快。不过，这确实说明了一个很重要的问题。在我的笔记本电脑上，最慢的解决方案（慢了有5倍）是使用锁定的那一个（方案2）。这一点重要吗？或许并不，你要知道，即使如此它仍然能在40秒内获取十亿次单例。（注：这篇文章距今已经有些时间了–我希望现在能有很好的表现）。这意味着，如果你每秒“只”获取四十万次单例，那么获取的成本只占性能的1%–所以提升它没太大用。现在，如果你要频繁的获取单例–是不是可以在循环中使用了？如果你那么在乎提高这一点性能，为何不在循环外声明一个局部变量，获取一次单例，再执行循环呢？对啦，这样即使最慢的实现也会变得轻松。</p>
<p>我非常乐意看到，在一个真实的应用中，使用简单锁定和使用更快方案之间，确实产生了显著的性能差异。</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p>有的时候，你需要在单例的构造函数中做一个工作，这有可能会造成异常，但可能对整个应用不会带来致命的影响。有可能，你的应用能够修复这个问题，然后想再尝试一次。在这个阶段使用类型初始化器来构造单例就会出现问题。不同的运行时对这种情况会有不同的处理，但我不知道那种运行时会做所需的事（再次运行类型初始化器），即使有，你的代码在别的运行时也可能被破坏。为了避免这个问题，我建议使用上页的第二种模式–只需要一个简单的锁，每次都检查一下，如果没有成功构建实例，就在方法/属性中构建实例。</p>
<p>感谢Andriy Tereshchenko提出这个问题。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>2006年1月7日略有修改；2011年2月12日更新</p>
<p>C#中有很多种实现单例模式的方法。有读者写信给我，详细介绍了他封装同步的方法，我承认这种方法可能在一些特殊情况下很有用（特别是你想要高性能，并且能够明确是否创建的单例，以及不管其他静态成员是够被调用都要延迟处理）。但我个人认为这种情况并不常出现，不值得在文章中继续讨论，但如果你碰到了这种情况，请给我<a href="mailto:skeet@pobox.com">发邮件</a>。（<em>原文作者邮箱</em>）</p>
<p>我个人更倾向于方案4，我只会在下面的情况下抛弃方案4：如果我需要在不触发初始化的情况下调用其他静态方法，或者我需要知道单例是否实例化。我不记得上次遇到这种情况是什么时候了，假如我碰到了，我可能会选择方案2，方案2还是不错的，很容易就能搞定。</p>
<p>方案5很优雅，但比方案2和方案4棘手，正如我上面所说，它的优势没那么有用。方案6是一种比较简单的实现延迟的方法，如果你使用的是 .Net 4，它的优势就是显著的延迟处理。目前，仅仅出于个人习惯，我仍然倾向于使用方案4–但是如果我是和没有开发经验的开发人员一起工作，我可能会选择方案6，因为这是一个简单且普遍使用的模式。</p>
<p>（我不会用方案1，因为它不完善，我也不会用方案3，因为它的优势没有方案5显著）</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/Singleton">Implementing the Singleton Pattern in C#</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>翻译</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>C#和.NET中的字符串</title>
    <url>/2021/01/18/String/</url>
    <content><![CDATA[<p><code>System.String</code>类型（C#中简写为<code>string</code>）是.NET中最重要的类型之一，不幸的是人们对它有很多误解。本文试图讲解该类型的一些基础知识。</p>
<h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串</h2>
<p>字符串大致上说就是一个字符序列，每个字符都是U+0000到U+FFFF范围内的<a href="https://home.unicode.org/">Unicode</a>字符（后面会<a href="#%E7%BC%96%E7%A0%81">详细介绍</a>）。字符串类型<code>string</code>（我之后都会用C#简写，而不是放<code>System.String</code>）有以下特点：<span id="more"></span></p>
<ul>
<li>是引用类型<br />
  这是一个常见的误区，认为字符串是一种值类型。这是因为它的不可变性（见下一点）使得它的行为有点像值类型。实际上，它就像一个普通的引用类型。关于值类型和引用类型之间的差异，可以参阅我关于<a href="https://jonskeet.uk/csharp/parameters.html">参数传递</a>和<a href="https://jonskeet.uk/csharp/memory.html">内存</a>的文章。</li>
<li>不可变性<br />
  你永远无法真正改变一个字符串的内容，至少是在不使用反射的安全代码中。正因如此，你经常会在最后改变了字符串变量的值。例如，代码<code>s = s.Replace (&quot;foo&quot;, &quot;bar&quot;);</code>并没有改变原始引用的字符串的内容——它只是将s的值设置为了一个新字符串，这个字符串是旧字符串的副本，只是“foo”被“bar”替换了。</li>
<li>重载<code>==</code>操作符<br />
  当使用<code>==</code>运算符比较两个字符串时，会调用<code>Equals</code>方法，该方法会检查字符串内容是否相等，而不是引用本身。例如，<code>&quot;hello&quot;.Substring(0，4)==&quot;hell&quot;</code>，虽然运算符两边的引用不同，但判断返回为True（它们都包含相同的字符序列，但引用的是两个不同的字符串对象）。请注意，只有在编译时运算符的两边都是字符串表达式时，运算符重载才会起作用——运算符不是多态应用的。对于编辑器而言，如果运算符的某一边的类型是对象（object），那么<code>==</code>运算符正常执行，只是简单判定引用是否相等。</li>
</ul>
<h2 id="驻留"><a class="markdownIt-Anchor" href="#驻留"></a> 驻留</h2>
<p>.NET有一个“驻留池”的概念，基本上就是一组字符串，它能确保每次引用同一个字符串字面量时，都能得到同一个字符串的引用。这可能与语言有关，但至少在C#和VB.NET中肯定是这样的，如果有某种语言不是如此，那还挺让人惊讶，因为IL是很容易做到这一点的（可能比不驻留字符串字面量更简单）。除了自动驻留字面量外，还可以使用<code>Intern</code>方法手动驻留字符串，并使用<code>IsInterned</code>方法检查池中是否已经存在有相同字符的驻留字符串。这个方法（<code>IsInterned</code>）会返回一个字符串而不是直观认为的布尔值——如果池中有相等的字符串，则返回该字符串的引用。否则，将返回<code>null</code>。同样的，<code>Intern</code>方法会返回一个对驻留字符串的引用——无论是你传入的字符串已在池中，或是创建了新的驻留字符串，还是池中已存在相同字符串，都是如此。</p>
<h2 id="字面量"><a class="markdownIt-Anchor" href="#字面量"></a> 字面量</h2>
<p>字面量是将字符串硬编码到C#程序中的方式。在C#中，有两种类型的字符串字面量——常规字符串字面量和转义字符串字面量。常规字符串字面量与许多其他语言（如Java和C）中的相似。都以<code>&quot;</code>开头和结尾，而有些字符（特别是<code>&quot;</code>本身，<code>\</code>，回车（CR）和换行（LF））需要“转义”才能在字符串中表示。转义字符串字面量几乎允许包含任何内容，并以第一个<code>&quot;</code>结束，而不是两个。即使是回车和换行也可以出现在字面量中！要想在字符串中显示<code>&quot;</code>，你需要写<code>&quot;&quot;</code>。转义字符串字面量通过在开头引号前添加@来进行区分。下面举一些例子，来说明这两种文字类型，以及它们表示的是什么：</p>
<table>
<thead>
<tr>
<th>常规字符串字面量</th>
<th>转移字符串字面量</th>
<th>结果字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;Hello&quot;</code></td>
<td><code>@&quot;Hello&quot;</code></td>
<td>Hello</td>
</tr>
<tr>
<td><code>&quot;Backslash: \\&quot;</code></td>
<td><code>@&quot;Backslash: \&quot;</code></td>
<td>Backslash: \</td>
</tr>
<tr>
<td><code>&quot;Quote: \&quot;&quot;</code></td>
<td><code>@&quot;Quote: &quot;&quot;&quot;</code></td>
<td>Quote: &quot;</td>
</tr>
<tr>
<td><code>&quot;CRLF:\r\nPost CRLF&quot;</code></td>
<td><code>@&quot;CRLF:</code><br><code>Post CRLF&quot;</code></td>
<td>CRLF:<br>Post CRLF</td>
</tr>
</tbody>
</table>
<p>请注意，只是为了编译器才区分不同类型的字符量。一旦字符串被编译后，就不存在常规字符串字面量和转义字符串字面量的区别了。</p>
<p>完整的转义序列如下：</p>
<ul>
<li><code>\'</code>——单引号，用于字符</li>
<li><code>\&quot;</code>——双引号，用于字符串</li>
<li><code>\\</code>——反斜杠</li>
<li><code>\0</code>——Unicode字符0</li>
<li><code>\a</code>——警报（字符7）</li>
<li><code>\b</code>——退格（字符8）</li>
<li><code>\f</code>——送表（字符12）</li>
<li><code>\n</code>——新的一行（字符10）</li>
<li><code>\r</code>——回车（字符13）</li>
<li><code>\t</code>——水平制表符（字符9）</li>
<li><code>\v</code>——垂直制表符（字符11）</li>
<li><code>\uxxxx</code>——带有十六进制值xxxx的字符的Unicode转义序列</li>
<li><code>\xn[n][n][n]</code>——带有十六进制值nnnn的字符的Unicode转义序列（可变长度版本的\uxxxx）</li>
<li><code>\Uxxxxxxxx</code>——十六进制值为xxxxxxx的字符的Unicode转义序列(用于生成代理字符)</li>
</ul>
<p>根据我的经验，其中的<code>\a</code>、<code>\f</code>、<code>\v</code>、<code>\x</code>和<code>\U</code>很少使用。</p>
<h2 id="字符串和调试器"><a class="markdownIt-Anchor" href="#字符串和调试器"></a> 字符串和调试器</h2>
<p>很多人在调试器中检查字符串时遇到了问题，无论是 VS .NET 2002还是 VS .NET 2003。讽刺的是，这些问题往往是由于调试器为了提供帮助而产生的，要么将字符串显示为带有反斜杠转义字符的常规字符串字面量，要么将其显示为带有前导@的转义字符串字面量。这就导致了很多问题，怎么去掉@呢，尽管事实上它本来就不存在——只是调试器的显示方式而已。另外，某些版本的VS .NET会在第一个空字符时停止显示字符串的内容，并错误地评估其Length属性，自己计算值，而不是询问管理代码。同样，它就会认为该字符串在第一个空字符处就结束了。</p>
<p>鉴于这一点引起的混乱，至少在你觉得有点奇怪时，最好尝试用不同的方法调试一下。我建议使用像下面这样的方法，它将以一种安全的方式将字符串的内容打印到控制台。可以根据你正在开发的应用程序的类型，把这些信息写到日志文件中，写到调试或跟踪监听器中，或者在消息框中弹出。</p>
<p>另外，作为一种交互式检查文本的方式，你可以使用一个我写的简单的Unicode探测器(<a href="https://csharpindepth.com/articles/Unicode#explorer">原文</a> <a href="/2021/01/14/Unicode/">译文</a>)——只需输入文本，就可以看到字符、UTF-16编码和UTF-8字节。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] LowNames = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;NUL&quot;</span>, <span class="string">&quot;SOH&quot;</span>, <span class="string">&quot;STX&quot;</span>, <span class="string">&quot;ETX&quot;</span>, <span class="string">&quot;EOT&quot;</span>, <span class="string">&quot;ENQ&quot;</span>, <span class="string">&quot;ACK&quot;</span>, <span class="string">&quot;BEL&quot;</span>, </span><br><span class="line">    <span class="string">&quot;BS&quot;</span>, <span class="string">&quot;HT&quot;</span>, <span class="string">&quot;LF&quot;</span>, <span class="string">&quot;VT&quot;</span>, <span class="string">&quot;FF&quot;</span>, <span class="string">&quot;CR&quot;</span>, <span class="string">&quot;SO&quot;</span>, <span class="string">&quot;SI&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DLE&quot;</span>, <span class="string">&quot;DC1&quot;</span>, <span class="string">&quot;DC2&quot;</span>, <span class="string">&quot;DC3&quot;</span>, <span class="string">&quot;DC4&quot;</span>, <span class="string">&quot;NAK&quot;</span>, <span class="string">&quot;SYN&quot;</span>, <span class="string">&quot;ETB&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CAN&quot;</span>, <span class="string">&quot;EM&quot;</span>, <span class="string">&quot;SUB&quot;</span>, <span class="string">&quot;ESC&quot;</span>, <span class="string">&quot;FS&quot;</span>, <span class="string">&quot;GS&quot;</span>, <span class="string">&quot;RS&quot;</span>, <span class="string">&quot;US&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayString</span> (<span class="params"><span class="built_in">string</span> text</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;String length: &#123;0&#125;&quot;</span>, text.Length);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> text)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">32</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;&lt;&#123;0&#125;&gt; U+&#123;1:x4&#125;&quot;</span>, LowNames[c], (<span class="built_in">int</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">127</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;(Possibly non-printable) U+&#123;0:x4&#125;&quot;</span>, (<span class="built_in">int</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;&#123;0&#125; U+&#123;1:x4&#125;&quot;</span>, c, (<span class="built_in">int</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存使用"><a class="markdownIt-Anchor" href="#内存使用"></a> 内存使用</h2>
<p>至少在现在的实现中，字符串占用了20+(n/2)*4个字节（n/2向下取整），n是字符串中的字符个数。字符串类型很特别，因为对象本身的大小是不同的。另一个能做到这一点的类（就我所知）是数组。本质上，字符串在内存中就是一个字符数组，加上数组的长度和字符串的长度（以字符为单位）。数组长度和字符长度并不总是相同，因为字符串可以使用mscorlib.dll进行“超额分配”，以使其构建更加容易（例如，<code>StringBuilder</code>就是这么做的）。虽然字符串对外界来说是不可变的，但mscorlib中的代码却可以改变其内容，所以<code>StringBuilder</code>会创建一个大于当前内容的内部字符数组，然后对字符串进行追加，直到字符数组不够大时，会再创建一个新的字符串，使其拥有更大的数组。字符串长度成员在其顶位还包含一个标志，用于说明字符串是否包含任何非ASCII字符。这样在某些情况下可以进行额外的优化。</p>
<p>虽然就API而言，字符串并不是以null作为终止（null-terminated）（<em>个人理解：末尾没有“\0”</em>），但字符数组确是以null终结（<em>个人理解：末尾是“\0”</em>），因此这意味着它可以直接传递给非管理函数，而不涉及任何复制调用，假定传递过程（inter-op）指定字符串应当以Unicode形式进行装配（marshalled）。</p>
<h2 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h2>
<p>（如果你不了解字符编码和Unicode，请先看我的相关文章(<a href="https://csharpindepth.com/articles/Unicode">原文</a> <a href="/2021/01/14/Unicode/">译文</a>)。）</p>
<p>正如文章开头所说，字符串总是采用Unicode编码。“大五码字符串”或“UTF-8编码字符串”是一种错误的概念（就.NET而言），这通常表明对编码或者.NET处理字符串的方式缺乏了解。理解这一点是非常重要的——如果把一个字符串当作一个非Unicode编码的有效文本来处理，几乎总会造成错误。</p>
<p>现在，Unicode编码字符集（Unicode的缺陷之一是一个名词会用于各种事物，包括一个编码字符集和一个字符编码方案）包含了65536多个字符。这意味着<code>char</code>(<code>System.Char</code>)不可能涵盖所有字符。这就导致了代用符的使用，U+FFFF以上的字符在字符串中被表示为两个字符。本质上，<code>string</code>使用UTF-16字符编码形式。大多数开发者很可能不需要知道太多，但至少值得了解一下。</p>
<h2 id="文化与国际化的怪事"><a class="markdownIt-Anchor" href="#文化与国际化的怪事"></a> 文化与国际化的怪事</h2>
<p>Unicode的一些怪异性导致了字符串和字符处理的怪异性。许多字符串方法都具有文化敏感性——换句话说，它们的作用取决于当前线程的文化。例如，你认为<code>&quot;i&quot;.toUpper()</code>返回的是什么？大多数人会说 “I”，但在土耳其语中，正确答案是 “İ” (Unicode U+0130，“拉丁文大写字母I，上面有点”)。要执行对文化不敏感的大小写变化，可以使用<code>CultureInfo.InvariantCulture</code>，将其传递给<code>String.ToUpper</code>的带有<code>CultureInfo</code>的重载。</p>
<p>在比较、排序和查找子串的索引时，还有更多的奇怪之处。它们中有的涉及文化特有性，有的则不涉及。例如，在所有文化中（据我所知），当使用<code>CompareTo</code>或<code>Compare</code>时，&quot;lassen &quot;和 “la\u00dfen”（其中的 &quot;sharp S &quot;或eszett是Unicode-escaped字符）被认为是相等的，但使用<code>Equals</code>时又不相等。<code>IndexOf</code>对eszett和&quot;ss&quot;的处理是一样的，除非使用<code>CompareInfo.IndexOf</code>并制定<code>CompareOptions.Ordinal</code>作为要使用的选项。</p>
<p>其他一些unicode字符对于普通的<code>IndexOf</code>根本不可见。 有人在C#新闻组中问到，为什么一个搜索/替换方法会进入一个无限循环。内容是循环使用<code>Replace</code>将所有双空格替换为单空格，并通过<code>IndexOf</code>检查是否已经完成，这样多个空格就会折叠成一个空格。不幸的是，由于原始字符串中两个空格之间有一个 &quot;奇怪 &quot;的字符，导致了该错误。<code>IndexOf</code>匹配了双空格，忽略了额外的字符，但<code>Replace</code>却没有。我不知道真实数据中到底是哪个字符，但可以用U+200C这个零宽度的非连接字符（不用管它到底是什么意思！）轻松再现。将其放在你要搜索的文本中间，<code>IndexOf</code>会忽略它，但<code>Replace</code>却不会。与之前的情况同样，为了使两个方法的行为一致，你可以使用<code>CompareInfo.IndexOf</code>传入<code>CompareOptions.Ordinal</code>。我猜测，有很多代码会在这样的 &quot;尴尬 &quot;数据上失效。(我也无法保证我的所有代码都对此免疫。)</p>
<p>微软有一些关于<a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms973919(v=msdn.10)">字符串处理的建议</a>——可以追溯到2005年，但它们仍然非常值得阅读。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>对于这样一个核心类型，字符串（以及一般的文本数据）比你最初预期的要复杂得多。尽管对于多文化背景下的比较和变化的一些细微之处目前你还无法理解，但了解这里列出的基础知识是很重要的。特别是，能够通过打印（logging）真实字符串数据，来诊断编码错误的造成的数据丢失，是至关重要的。</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/Strings">Strings in C# and .NET</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>翻译</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode和.NET</title>
    <url>/2021/01/21/Unicode/</url>
    <content><![CDATA[<h2 id="unicode探测器"><a class="markdownIt-Anchor" href="#unicode探测器"></a> Unicode探测器</h2>
<p>这部分以前是在文章末尾，但这其实是最有用的，所以我认为它应当放在文章一开始的地方，广而告之。下面的工具是一段小小的Javascript代码，它可以显示你输入到文本框中的任何字符串的有用信息。它不仅可以帮你找出代码中字符的UTF-8表示形式，而且我发现它还可以用于排查因为无法打印的文本而造成的问题。</p>
<p>
  在这里输入文本:
  <input type="text" id="explorer-input" onkeyup="displayData();" />
</p>
<table class="grid">
    <thead>
        <tr>
            <th>Character</th>
            <th>Unicode</th>
            <th>UTF-16</th>
            <th>UTF-8</th>
        </tr>
    </thead>
    <tbody id="explorer-output-tbody">
</table>
<script>
function createCell(text) 
{
    var element = document.createElement("td");
    element.appendChild(document.createTextNode(text));
    return element;
}
function toHex(value, minLength) 
{
    var hex = value.toString(16).toUpperCase();
    if (hex.length >= minLength) {
        return hex;
    } else {
        hex = "000000" + hex;
        return hex.substring(hex.length - minLength);
    }
}
function joinHex(array, hexLength) 
{
    var result = "";
    for (var i = 0; i < array.length; i++) {
        if (i != 0) {
            result += " ";
        }
        result += toHex(array[i], hexLength);
    }
    return result;
}
function isHighSurrogate(codeUnit) 
{
    return codeUnit >= 0xd800 && codeUnit <= 0xdbff;
}
function isLowSurrogate(codeUnit) 
{
    return codeUnit >= 0xdc00 && codeUnit <= 0xdfff;
}
function combineSurrogates(high, low) 
{
    return 0x10000 + (high - 0xd800) * 0x400 + (low - 0xdc00);
}
function extractAndShift(value, firstBit, count) 
{
    // This has the correct bottom-most bits, but also information to remove.
    var shifted = value >> (firstBit - count);
    // This is the same as (shifted), but with the bottom-most bits all cleared.
    // In other words, this is the part to remove.
    var extra = (value >> firstBit) << count;
    return shifted - extra;
}
function toUtf8(codePoint) 
{
    if (codePoint < 0x80) {
        return [codePoint];
    } else if (codePoint < 0x800) {
        return [0xc0 | extractAndShift(codePoint, 11, 5),
        0x80 | extractAndShift(codePoint, 6, 6)];
    } else if (codePoint < 0x10000) {
        return [0xe0 | extractAndShift(codePoint, 16, 4),
        0x80 | extractAndShift(codePoint, 12, 6),
        0x80 | extractAndShift(codePoint, 6, 6)];
    } else {
        return [0xf0 | extractAndShift(codePoint, 21, 3),
        0x80 | extractAndShift(codePoint, 18, 6),
        0x80 | extractAndShift(codePoint, 12, 6),
        0x80 | extractAndShift(codePoint, 6, 6)]
    }
}

function displayData() 
{
        var text = document.getElementById("explorer-input").value;
        var table = document.getElementById("explorer-output-tbody");
        table.innerHTML = "";
        for (i = 0; i < text.length;) 
        {
            // First work out all the tricky Unicode parts...
            var codePoint = text.charCodeAt(i);
            var length = 1;
            var surrogate = false;
            if (isHighSurrogate(codePoint) && i < text.length - 1
                && isLowSurrogate(text.charCodeAt(i + 1))) {
                var high = codePoint;
                var low = text.charCodeAt(i + 1);
                codePoint = combineSurrogates(high, low);
                length = 2;
                surrogate = true;
            }
            var utf8 = toUtf8(codePoint);
            var utf16 = surrogate ? [high, low] : [codePoint];

            // The rest is just display
            var row = document.createElement("tr");
            row.appendChild(createCell(text.substring(i, i + length)));
            row.appendChild(createCell("U+" + toHex(codePoint, 4)));
            row.appendChild(createCell(joinHex(utf16, 4)))
            row.appendChild(createCell(joinHex(utf8, 2)))
            table.appendChild(row);
            i += length;
        }
}
</script>
<span id="more"></span>
<p>该表格将文本框中的文本分解为Unicode字符。它不执行任何形式的规范化，因此一个重音字符可能会以一个字符或多个字符的形式出现，这取决于它是以包括重音在内的单个字符（如é）的形式输入，还是以一个非重音字符后的组合字符的形式输入（如é——是的，这确实与前面的例子不同；复制并粘贴这两个字符到上文工具中看看！）然而，它确实将输入分解为Unicode字符，而不仅仅是UTF-16代码单位；一个代理对被视为了一个单一字符。例如，𠬠（这显然不是一个有效的Unicode字符，但它似乎又有一个能被普遍理解的含义和字形）显示为U+20B20。</p>
<p>第一列只是显示字符。第二列显示Unicode码（U+0000到U+10FFFF），在<a href="http://unicode.org/charts/">Unicode码图</a>中可以方便地查找。第三列显示组成字符的UTF-16单位：这些是在C#（或Java，或Javascript）脚本中出现的字符（<code>char</code>）值。对于基本多语言平面（Basic Multilingual Plane）的字符，这将只是一个单一的代码单元；对于其他字符，它就是代理对（先高后低）。第四列显示以字节为单位的UTF-8表示的字符。</p>
<h2 id="本文适用范围"><a class="markdownIt-Anchor" href="#本文适用范围"></a> 本文适用范围</h2>
<p>这是一个很大的话题。不要指望这篇文章能做太多的事——事实上，如果你认为你已经对字符编码和类似的东西有相当的经验和知识，这篇文章很可能不会带给你任何新的或有用的东西。但是，还是有很多人不明白二进制和文本的区别，也不知道什么是字符编码等等。这篇文章就是为这些人写的。文中会提到一些高级主题，但只是为了让读者意识到其存在，而不会对其进行过多指导。</p>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<p>下面的链接至少可能和本文一样有用，甚至可能更有用些——其中也有更多值得阅读的内容。在写本文时，我对其中所有的内容（甚至更多）都进行参考了。其中很多不错的信息，虽然这个页面上可能有一些不准确的地方（如果你发现了，请发邮件给我：<a href="mailto:skeet@pobox.com">skeet@pobox.com</a>），但这些资源应该是正确的。</p>
<ul>
<li><a href="https://home.unicode.org/">Unicode网站主页</a><br />
  关于Unicode的权威资源，虽然听着有点吓人，但上面有你需要的关于Unicode的所有答案——下面这些有所帮助的链接就是来自该网站。</li>
<li><a href="http://www.unicode.org/glossary/">Unicode术语表</a><br />
  在讨论字符编码（等）问题时，许多术语的定义一目了然。</li>
<li><a href="http://www.unicode.org/faq/">Unicode常见问题</a><br />
  对上百个常见问题分门别类，进行解答。</li>
<li><a href="https://www.cl.cam.ac.uk/~mgk25/unicode.html">Unix/Linux UTF-8/Unicode常见问题</a><br />
  如果你不喜欢Unix/Linux，不要被标题吓倒——里面的大部分信息都与.NET问题相关。</li>
<li><a href="http://www.unicode.org/reports/tr17/">Unicode字符编码模型</a><br />
  提供更多关于&quot;字符编码方案&quot;等准确含义的信息。</li>
<li><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">每位软件开发人员一定要了解的Unicode和字符集的最低要求（没有借口！）</a><br />
  和本文有些类似，但没有重点针对 .NET。</li>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode">Unicode的优势</a><br />
  又是一篇值得一读的介绍性文章。</li>
</ul>
<h2 id="二进制和文本巨大的区别"><a class="markdownIt-Anchor" href="#二进制和文本巨大的区别"></a> 二进制和文本——巨大的区别</h2>
<p>大多数现代计算机语言（和一些较老的语言）在 &quot;二进制 &quot;内容和 “字符”（或 “文本”）内容之间有很大的区别。两者的差异和本能感觉的差异区别不大，但为了清楚起见，我会将其定义如下：</p>
<ul>
<li>二进制内容是一个八位字节（通俗地说就是字节）的序列，没有附加任何内在意义。即使可能存在有外部的手段来解读一段二进制内容，比如一张图片或是一个可执行文件，但其内容本身就是一个字节序列。（那些老学究读者注意啦：从现在开始，不会再用“八位数”（octet）这个词了，我会用“字节”（byte）来代替，尽管严格来说，一个字节不一定是八位字节，比如说，已经有了9位字节的架构。我认为在当今时代，去做这个区分没有什么用处，读者可能更喜欢用“字节”这个词。）</li>
<li>字符内容是一个字符序列。</li>
</ul>
<p><a href="http://www.unicode.org/glossary/#character">Unicode术语表</a>对字符的定义是：</p>
<ol>
<li>书面语言中具有语义价值的最小成分；表示的是抽象的意义和/或形状，而不是具体的形状（另见字形），尽管在代码表中，某种形式的视觉表示对读者的理解至关重要。</li>
<li>抽象字符的同义词。（参见第3.3节字符和编码表示中的定义D3。）</li>
<li>Unicode字符编码的基本编码单位。</li>
<li>源于中国的表意文字元素的英文名称。（见表意文字（2）。）</li>
</ol>
<p>这对你来说可能是一个很有用的定义，也可能不是，但大多数情况下，你只需要本能的理解为——一个字符就是类似于“大写字母A”、“数字1”的东西。还有一些不太明显的字符，如：组合字符，如 “急促的口音（an acute accent）”，控制字符，如 “换行”，以及格式化字符（是不可见的，但会影响周围的字符）。重要的是，这些基本上都是某种形式的 “文本”。它们都具有某种意义。</p>
<p>现在，不幸的是，在这之前两者的区别已经很模糊了——C程序员往往习惯于把“字节（byte）”和“char”看作是可以互换的，以至于他们会说要读取一定数量的字符，尽管其中的内容完全是二进制的。在 .NET和Java等现代环境中，两者的区别是很明显的，并且是存在于IO库中的，这可能导致人们试图通过读写字符来复制二进制文件时，导致输出的损坏。</p>
<h2 id="unicode从何而来"><a class="markdownIt-Anchor" href="#unicode从何而来"></a> Unicode从何而来？</h2>
<p>Unicode协会是一个尝试标准化处理字符数据的机构，包括将其转换为二进制格式（也就是编码和解码）。还有一套ISO标准（各种版本中的10646）也在做类似的事情；Unicode和ISO 10646在很大程度上可以被认为是在做 “同样的事情”，因为它们几乎在所有方面都是兼容的。（理论上，ISO 10646定义了更大的潜在字符集，但这可能不会成为一个问题）。大多数现代计算机语言和环境，如.NET和Java，都使用Unicode来表示字符。Unicode定义了抽象字符集（其所涵盖的字符集）、编码字符集（从字符集中的每个字符到非负整数的映射）、一些字符编码形式（从编码字符集中的非负整数到“代码单位”（如字节）序列的映射）和一些字符编码方案（从代码单位序列到序列化字节序列的映射）。字符编码形式和字符编码方案之间的区别略有些微妙，但考虑到了像字节序（大端，小端）这样的东西。（例如，UCS-2编码单元序列0xc2 0xa9可以序列化为0xc2 0xa9或0xa9 0xc2，这是由字符编码方案决定的。）</p>
<p>理论上，Unicode抽象字符库最多可以容纳1114112个字符，不过很多字符是保留为无效的，其余的也不可能全部被分配。每个字符都是0到1114111（0x10ffff）之间的整数。例如，大写字母A的编码为65。直到几年前，人们还期望只需要用0到2<sup>16</sup>-1范围内的字符，这意味着每个字符只需要2个字节来表示。不幸的是，越来越多的字符被引入，代理对的概念也被提了出来。这些事情会引生一些重大的混乱（至少，这会会使我产生重大的混乱），本文其余部分的大部分内容将忽略它们的存在——我将在 &quot;讨厌的部分 &quot;这一章节中简要介绍它们。</p>
<h2 id="net提供了什么"><a class="markdownIt-Anchor" href="#net提供了什么"></a> .NET提供了什么？</h2>
<p>如果上面提到的内容听起来比较混乱，不用担心。只需要注意其中的区别，实际上这些情况不会经常出现。大多数时候，你只是想把一些字节转换成字符，或者把字符转成字节。这就是<code>System.Text.Encoding </code>类，以及<code>System.Char</code>结构（C#中又称<code>char</code>）和<code>System.String</code>（C#中又称<code>string</code>）的作用。</p>
<p><code>char</code>是最基本的字符类型。每个<code>char</code>都是一个单一的Unicode字符，它在内存中占用2个字节，取值范围是0-65535。请注意，并非所有的值都是有效的Unicode字符。</p>
<p>基本上，字符串（<code>string</code>）就是一个字符序列。它是不可变的，这意味着一旦你创建了一个字符串实例（无论你是怎么创建的），你就无法改变它了——字符串类中的各种方法让你以为可以改变字符串，实际上都只是返回了一个基于原始字符串做过相应改变的新字符串。</p>
<p><code>System.Text.Encoding</code>类提供了将字节数组转换为字符数组或字符串的方法，当然也有反向方法（将字符数组或字符串转换为字节数组）。该类本身是抽象类；各种实现由 .NET提供，而且也很容易实例化，如果用户愿意，也可以编写自己的派生类（这种需求十分罕见——大多是情况下，使用内置的实现就可以了）。可以为一种编码提供单独的编码器和解码器，两者在调用之间维持其状态。这对于多字节字符编码方案是有必要的，因为在某些情况下，只有在接收到流中所有的字节后才能进行解码。例如，如果UTF-8解码器收到<code>0x41 0xc2</code>，可以返回第一个字符（大写字母A），但必须接收到第三个字节，才能确定第二个字符是什么。</p>
<h2 id="内置编码方案"><a class="markdownIt-Anchor" href="#内置编码方案"></a> 内置编码方案</h2>
<p>.NET提供了各种 &quot;开箱即用 &quot;的编码方案。下面是对各种不同编码方案的描述（就我能找到的而言），以及如何检索它们。</p>
<h3 id="ascii"><a class="markdownIt-Anchor" href="#ascii"></a> ASCII</h3>
<p>ASCII是最常见也最容易被误解的字符编码之一。与人们普遍认为的不同，它只有7位——意思是ASCII码的值不会高于127（2<sup>7</sup>-1）。如果有人说想要的编码是（例如）“ASCII 154”，那么他可能根本不知道他说的编码到底是啥。如果非要解释一下，他可能会说这是“扩展ASCII”。但其实没有一种编码方案叫做“扩展ASCII”。倒是有很多8位编码算是ASCII的超集，通常他们所说的是其中的一种——他们电脑上默认的Windows代码页（Windows Code Page）。每个ASCII字符在ASCII编码中的值与Unicode编码字符集中的值相同，换句话说，ASCII内的所有字符ASCII x的值与Unicode x的值相同。在我看来，.NET <code>ASCIIEncoding</code>类（使用<code>Encoding.ASCII</code>属性可以很容易地检索到它的一个实例）稍微有点奇怪，因为它似乎只是通过剥离掉底部7以上的所有位来进行编码。这意味着，例如，Unicode字符0xb5（“微号”（μ））在编码再解码后将成为Unicode 0x35（“数字五”），而不是像其他一些字符一样，显示它是一个不包含在ASCII中的字符。</p>
<h3 id="utf-8"><a class="markdownIt-Anchor" href="#utf-8"></a> UTF-8</h3>
<p>UTF-8是表示Unicode字符的一种通用方式。每个字符被编码为1-4个字节的序列。(所有值小于65536的字符都是以1-3字节编码的；我没有核实过 .NET是将代理字符编码为两个1-3字节的序列，还是一个4字节的序列)。它可以表示所有的字符，它是 &quot;兼容ASCII &quot;的，因为ASCII中的任意字符序列在UTF-8中都会被编码成与ASCII中完全相同的字节序列。此外，第一个字节可以表明整个字符需要多少额外的字节（如果有的话）才能被解码。UTF-8本身不需要字节排序标记（byte-ordering mark）(BOM)，尽管它可以用来证明文件确实是UTF-8格式的。UTF-8编码的BOM总是0xef 0xbb 0xbf。在.NET中获取UTF-8编码很简单——使用<code>Encoding.UTF8</code>属性。事实上，很多时候你甚至不用这样做——许多类（如<code>StreamWriter</code>）在没有指定编码时默认使用UTF-8。(不要被<code>Encoding.Default</code>误导——那完全是另一回事！)不过，为了可读性，我还是建议要指定编码。</p>
<h3 id="utf-16和ucs-2"><a class="markdownIt-Anchor" href="#utf-16和ucs-2"></a> UTF-16和UCS-2</h3>
<p>UTF-16实际上是.NET内部维护字符的方式。每个字符都被编码为2个字节的序列，但代理字符除外，代理字符需要4个字节。UTF-16和UCS-2（也被称为 “Unicode”）之间唯一的区别就是使用代理对的条件，后者只能表示值为0-0xffff的字符。UTF-16可以表示成大端、小端，也可以是机器依赖性的可选BOM（0xff 0xfe代表小端，0xfe 0xff代表大端）。在.NET中，我认为代理对的问题已经被遗忘了，代理对中的每一个值都被视为一个单独的字符，使得UCS-2和UTF-16以一种模糊的方式 &quot;相同&quot;了。（如果要了解UCS-2和UTF-16的具体差异，恐怕需要对代理字符有更深入的理解——如果你想要知道两者差异的细节，那你有可能会比我知道的还多。）大端编码可以使用<code>Encoding.BigEndianUnicode</code>检索，小端编码可以使用<code>Encoding.Unicode</code>检索。两者都是<code>System.Text.UnicodeEncoding</code>的实例，你也可以在编码时使用适当的参数（是否使用BOM，使用大段还是小端）构造出实例。我认为（虽然我没测试过）当解码二进制内容时，内容中的BOM会覆盖编码器中大小端的设置，所以如果程序员知道是大端还是小端或者知道内容是否包含BOM，就不需要做额外的工作。</p>
<h3 id="utf-7"><a class="markdownIt-Anchor" href="#utf-7"></a> UTF-7</h3>
<p>以我的经验来说，UTF-7很少使用，但是它可以将Unicode（可能只有前65535个字符）完全编码成ASCII字符（不是字节！）。这对于那些只支持ASCII字符或某些ASCII字符子集（如，EBCDIC编码）的邮件网关是很有用的。这个描述听着有点冗长，这是因为：我还没详细研究过它，也不打算研究。如果你需要用它，你可能需要好好地理解一下，反正要是你用不到，就别管它了。在.NET中，可以使用<code>Encoding.UTF7</code>检索编码实例。</p>
<h3 id="windowsansi代码页"><a class="markdownIt-Anchor" href="#windowsansi代码页"></a> Windows/ANSI代码页</h3>
<p>Windows代码页一般是单字节或双字节字符集，分别编码到256或65536字符。每一个都是有编号的，可以使用<code>Encoding.GetEncoding(int)</code>来检索已知代码页编号的编码。编码页对那些存储在“默认编码页”中的遗留数据有很大用处。可以使用<code>Encoding.Default</code>来检索默认代码页的编码。同样，我也尽量避免使用代码页。更多信息可以在MSDN中查找。</p>
<h3 id="iso-8859-1latin-1"><a class="markdownIt-Anchor" href="#iso-8859-1latin-1"></a> ISO-8859-1(Latin-1)</h3>
<p>与ASCII码一样，Latin-1中的每个字符都与Unicode中的相同。我还不能确定Latin-1是否在128到159之间存在一个未定义字符的“洞”，或者它是否包含了与Unicode相同的控制字符。（我以前倾向于存在“洞”的这个想法，但<a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">维基百科</a>不同意，所以我对此无法下定论）。Latin-1与代码页28591相同，所以获取它的编码很简单：<code>Encoding.GetEncoding (28591)</code>。</p>
<h2 id="流读取和写入"><a class="markdownIt-Anchor" href="#流读取和写入"></a> 流，读取和写入</h2>
<p>流本质上就是二进制的——从根本上讲，它们是以字节为单位进行读写的。任何带有字符串的事物都会以某种形式进行二进制转换，这有可能正是你想要的也有可能不是。用于读写文本流的分别的是<code>System.IO.TextReader</code>和<code>System.IO.TextWriter</code>。如果你已经有了一个流，可以分别使用<code>System.IO.StreamReader</code>(派生自<code>TextReader</code>)和<code>System.IO.StreamWriter</code>(派生自<code>TextWriter</code>)，你可以用你想用的编码和流对其进行构建。如果你没有指定编码，默认使用UTF-8。下面是将一个文件从UTF-8转为UCS-2的示例代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FileConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> BufferSize = <span class="number">8096</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.Length != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine </span><br><span class="line">                (<span class="string">&quot;Usage: FileConverter &lt;input file&gt; &lt;output file&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Open a TextReader for the appropriate file</span></span><br><span class="line">        <span class="keyword">using</span> (TextReader input = <span class="keyword">new</span> StreamReader </span><br><span class="line">               (<span class="keyword">new</span> FileStream (args[<span class="number">0</span>], FileMode.Open),</span><br><span class="line">                Encoding.UTF8))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open a TextWriter for the appropriate file</span></span><br><span class="line">            <span class="keyword">using</span> (TextWriter output = <span class="keyword">new</span> StreamWriter </span><br><span class="line">                   (<span class="keyword">new</span> FileStream (args[<span class="number">1</span>], FileMode.Create),</span><br><span class="line">                    Encoding.Unicode))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Create the buffer</span></span><br><span class="line">                <span class="built_in">char</span>[] buffer = <span class="keyword">new</span> <span class="built_in">char</span>[BufferSize];</span><br><span class="line">                <span class="built_in">int</span> len;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Repeatedly copy data until we&#x27;ve finished</span></span><br><span class="line">                <span class="keyword">while</span> ( (len = input.Read (buffer, <span class="number">0</span>, BufferSize)) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    output.Write (buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，这个示例使用TextReader和TextWriter带有流参数的构造函数。还有一些构造函数采用文件名作为参数，这样你就不必在你的代码中手动开启一个<code>FileStream</code>。其他参数，如缓冲区大小和是否检测BOM（如果存在），都是可用的——详细内容请查阅文档。最后，<a href="http://xn--0mq.NET">从.NET</a> 2.0开始，你也应该去看看<a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.file">File</a>类提供的各种便利方法。</p>
<h2 id="困难的部分"><a class="markdownIt-Anchor" href="#困难的部分"></a> 困难的部分</h2>
<p>好了，这些就是Unicode的基础知识。还有很多额外的部分，其中一些已经也有所涉及，但是大家应该意识到了，这些内容不大可能和实际的应用有关联，也不值得去做整理。我并没有对此提供任何通用的技术手段或指导原则——我只是想让大家意识到它的存在。这也绝不是一个详尽的清单——这些只是一些令人讨厌的部分。重要的是要认识到，这里的很多难题并不是Unicode协会的错——就像日期和时间以及其他任何数字的国际化问题一样，人类在其历史过程中就已经陷入了一个的棘手局面。</p>
<h3 id="文化敏感性的搜索和变化"><a class="markdownIt-Anchor" href="#文化敏感性的搜索和变化"></a> 文化敏感性的搜索和变化</h3>
<p>这些内容在我关于.NET字符串处理的文章(<a href="https://csharpindepth.com/articles/Strings#culture">原文</a> <a href="/2021/01/18/String/#%E6%96%87%E5%8C%96%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96%E7%9A%84%E6%80%AA%E4%BA%8B">译文</a>)中有所涉及。</p>
<h3 id="代理对"><a class="markdownIt-Anchor" href="#代理对"></a> 代理对</h3>
<p>现在Unicode有超过65536个字符，无法仅用两个字节来全部表示。<a href="http://xn--4gqvd32t5sov50ao34a.NET">这意味着一个.NET</a> <code>char</code>值无法存储所有可能的值。UTF-16使用的解决方案是代理对：使用一对16位值，每个值在0xd800和0xdfff之间。换句话说，两个“排好序”的字符组成一个“真实”的字符。(UCS-4和UTF-32通过使用范围更广的值来完全解决这个问题——当使用4个字节表示时，就可以把所有可能的字符都涵盖进去。) 这是一个令人头疼的问题——这意味着10个字符组成的字符串实际上可以代表5到10个“真正的”Unicode字符。很多年前，大多数不涉及科学/数学符号和汉字的应用程序都不可能需要太过担心这个问题——但表情符号的出现，大大改变了这种情况。</p>
<h3 id="组合字符"><a class="markdownIt-Anchor" href="#组合字符"></a> 组合字符</h3>
<p>并非所有的字符都会在屏幕上绘制一个字符。一个有重音的字符可以表示为：无重音的字符和一个重音字符的组合字符。有些GUI系统会支持组合字符，有些则不支持——你的判断会影响你的应用程序。</p>
<h3 id="规范化"><a class="markdownIt-Anchor" href="#规范化"></a> 规范化</h3>
<p>一部分原因，是因为有像组合字符这样的情况，就会在某种情形下出现多个字符表示一个单一字符的情况。字符序列可以通过尽可能使用组合字符或尽可能避免使用组合字符进行规范化。你的应用程序会将表示同一个实际字符的两个不同字符序列视作相同的吗？你所需要的任意组件是否依赖于以某种特定方式归一化的序列？</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/Unicode">Unicode and .NET</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>翻译</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown功能记录</title>
    <url>/2021/01/06/Markdown/</url>
    <content><![CDATA[<h3 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h3>
<h1 id="一级标题"><a class="markdownIt-Anchor" href="#一级标题"></a> 一级标题</h1>
<h2 id="二级标题"><a class="markdownIt-Anchor" href="#二级标题"></a> 二级标题</h2>
<h3 id="三级标题"><a class="markdownIt-Anchor" href="#三级标题"></a> 三级标题</h3>
<hr />
<h3 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h3>
<blockquote>
<p>该行内容为引用</p>
<blockquote>
<p>该行内容为引用</p>
<blockquote>
<p>该行内容为引用</p>
</blockquote>
</blockquote>
</blockquote>
 <span id="more"></span>
<hr />
<h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3>
<p><code>this is a code</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;test.h&quot;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>这是标题</span><a href="http://www.baidu.com">百度</a></figcaption><table><tr><td class="code"><pre><span class="line">code snippet</span><br><span class="line">code snippet</span><br><span class="line">code snippet</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>这是一段C++代码</span><a href="http://www.cplusplus.com/">C++</a></figcaption><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;test.h&quot;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><figcaption><span>这是一段OC代码</span></figcaption><table><tr><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="复选框"><a class="markdownIt-Anchor" href="#复选框"></a> 复选框</h3>
<ul>
<li>[ ] this is a task</li>
<li>[x] this is a finished task</li>
</ul>
<hr />
<h3 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h3>
<ul>
<li>item1</li>
<li>item2</li>
<li>item3</li>
<li>item6
<ul>
<li>item7</li>
</ul>
</li>
</ul>
<hr />
<h3 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h3>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>cell 1</td>
<td>cell 2</td>
</tr>
<tr>
<td>balabala</td>
<td>lalalalal</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h3>
<p><em>斜体</em><br />
<strong>粗体</strong><br />
<em><strong>斜体粗体</strong></em><br />
<s>删除线</s><br />
<ins>Inserted text</ins><br />
<mark>mark</mark><br />
<font color=red size=5>红色</font><br />
<font color=gray size=10>灰色</font><br />
H<sub>2</sub>0<br />
29<sup>th</sup><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mi>x</mi><mi>y</mi></mfrac></mrow><annotation encoding="application/x-tex">\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2854em;vertical-align:-0.481108em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{xyz}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">x</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mn>3</mn></mroot></mrow><annotation encoding="application/x-tex">\sqrt[3]{x+y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.26055499999999987em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6335540000000002em;"><span style="top:-2.811334em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7794450000000002em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.739445em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26055499999999987em;"><span></span></span></span></span></span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mi>x</mi><mi>y</mi></mfrac></mrow><annotation encoding="application/x-tex">\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2298399999999998em;vertical-align:-0.481108em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.748732em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munderover><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munderover><mfrac><mi>x</mi><mi>y</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.176272em;vertical-align:-0.8804400000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2958319999999999em;"><span style="top:-2.382892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span><span style="top:-3.89444em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.853216em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<hr />
<h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3>
<blockquote>
<p>本地相对路径图片</p>
</blockquote>
<p><img src="/image/example.jpg" alt="example" /></p>
<blockquote>
<p>Hexo标签插件图片</p>
</blockquote>
<img src="/image/example.jpg" class="" title="This is an example image">
<blockquote>
<p>网络图片</p>
</blockquote>
<p><img src="https://octodex.github.com/images/dojocat.jpg" alt="example" /></p>
<hr />
<h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3>
<p><a href="https://www.baidu.com">百度</a></p>
<h3 id="注脚"><a class="markdownIt-Anchor" href="#注脚"></a> 注脚</h3>
<p>Here is a footnote reference,<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> and another.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<h3 id="emoji"><a class="markdownIt-Anchor" href="#emoji"></a> emoji</h3>
<p>😄<br />
🐷</p>
<h3 id="鼠标悬浮标注缩写"><a class="markdownIt-Anchor" href="#鼠标悬浮标注缩写"></a> 鼠标悬浮标注（缩写）</h3>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification<br />
is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="block"><a class="markdownIt-Anchor" href="#block"></a> block</h3>
<blockquote><p>content</p>
<footer><strong>[author[</strong><cite>source]] [link] [source_link_title]</cite></footer></blockquote>
<blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Here is the footnote. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Here’s one with multiple blocks.<br />
Subsequent paragraphs are indented to show that they<br />
belong to the previous footnote. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>C#和beforefieldinit属性</title>
    <url>/2021/01/11/beforefieldinit/</url>
    <content><![CDATA[<p>你觉得你能准确预测C#初始化发生的时间吗？这可比你想象的要复杂得多…</p>
<p><strong>请注意，所有结果都是我在C#编译器和CLR的某些（现在还没说明）组合上看到的。你可能会观察到不同的行为，而这些行为仍然遵循规范规定的内容。随着平台和实现的组合越来越多，想要穷尽也没啥意思。</strong>  <span id="more"></span></p>
<h2 id="静态构造函数和类型初始化器的区别"><a class="markdownIt-Anchor" href="#静态构造函数和类型初始化器的区别"></a> 静态构造函数和类型初始化器<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的区别</h2>
<p><a href="/2021/01/07/Implementing-the-Singleton-Pattern-in-C/index.html">单例模式</a>的一些实现依赖于静态构造函数和类型初始化器的行为，特别是在调用时间方面。</p>
<p>C#规范中规定：</p>
<p>一个类的静态构造函数在给定的应用域中最多执行一次。静态构造函数的执行是由应用域中的下列情况第一次出现时触发的：</p>
<ul>
<li>该类的一个实例被创建。</li>
<li>该类的任意一个静态成员被引用。</li>
</ul>
<p>CLI规范(ECMA 335)在8.9.5节中规定：</p>
<ol>
<li>一个类可以有一个类型初始化方法，也可以没有</li>
<li>一个类型可以为它的类型初始化方法指定一个宽松语义（relaxed semantic）（为了方便，下文称之为<em>BeforeFieldInit</em>）。</li>
<li>如果被标记为<em>BeforeFieldInit</em>，那么该类型的初始化方法会在第一次访问该类型的静态字段或者之前的某个时间执行。</li>
<li>如果没有被标记为<em>BeforeFieldInit</em>，那么该类型的初始化方法会在下列情况下执行：
<ul>
<li>首次访问该类型的任何静态或实例字段。</li>
<li>首次调用该类型的任何静态、实例或虚拟方法。</li>
</ul>
</li>
</ol>
<p>C#规范暗示，任何带有静态构造函数的类型都不应该用<em>beforefieldinit</em>标记。事实上，编译器也坚持了这一点，但效果略显怪异。我怀疑很多程序员认为（就像我长期以来做的那样），下列类在语义上是等价的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">object</span> o = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">object</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，这两个类并不相同。它们都有类型初始化器-并且两者一模一样。但是第一个没有静态构造函数，而第二个却有。这就意味着第一个类被标记成了<em>beforefieldinit</em>，它的类型初始化器会在其静态字段首次引用前的任何时刻被调用。静态构造函数甚至什么都不用做。下面的第三个类和第二个类一样：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">object</span> o = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我认为这是造成巨大混乱的根源-尤其是在单例的实现方面。</p>
<h2 id="beforefieldinit的奇特性-是否延迟lazy"><a class="markdownIt-Anchor" href="#beforefieldinit的奇特性-是否延迟lazy"></a> <em>beforefieldinit</em>的奇特性-是否延迟（Lazy）</h2>
<p><em>beforefieldinit</em>标志有个奇怪的效果，那就是两个一样的类型初始化器，有<em>beforefieldinit</em>标志的要比没有的更早调用-甚至可能会被滞后调用，或者根本不调用。考虑下面的程序：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> x = EchoAndReturn (<span class="string">&quot;In type initializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">EchoAndReturn</span> (<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine (s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Driver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting Main&quot;</span>);</span><br><span class="line">        <span class="comment">// Invoke a static method on Test</span></span><br><span class="line">        Test.EchoAndReturn(<span class="string">&quot;Echo!&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;After echo&quot;</span>);</span><br><span class="line">        <span class="comment">// Reference a static field in Test</span></span><br><span class="line">        <span class="built_in">string</span> y = Test.x;</span><br><span class="line">        <span class="comment">// Use the value just to avoid compiler cleverness</span></span><br><span class="line">        <span class="keyword">if</span> (y != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;After field access&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序的会有多种运行结果。运行时可能会在加载程序集时运行类型初始化器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In type initializer</span><br><span class="line">Starting Main</span><br><span class="line">Echo!</span><br><span class="line">After echo</span><br><span class="line">After field access</span><br></pre></td></tr></table></figure>
<p>也可能在静态方法第一次运行时运行…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting Main</span><br><span class="line">In type initializer</span><br><span class="line">Echo!</span><br><span class="line">After echo</span><br><span class="line">After field access</span><br></pre></td></tr></table></figure>
<p>甚至等到第一次访问字段时运行…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting Main</span><br><span class="line">Echo!</span><br><span class="line">After echo</span><br><span class="line">In type initializer</span><br><span class="line">After field access</span><br></pre></td></tr></table></figure>
<p>（理论上，类型初始化器甚至可能在“Echo！”后，“After Echo”前运行。不过，如果有任何运行时真的出现这种行为，也是很让我惊讶了。）在<code>Test</code>中使用静态构造函数，只会出现中间的那种情况，所以<em>beforefieldinit</em>可以让类型初始化器延迟调用（相比于最后一种结果）或提前调用（相比于第一种结果）。我猜想即使是那些知道<em>beforefieldinit</em>存在的开发者也会对此感到惊讶。MSDN文档对于<code>TypeAttributes.BeforeFieldInit</code>的介绍很少。它是这样描述这个标志的：</p>
<p><strong>规定调用类型的静态构造函数不会强制系统初始化该类型。</strong></p>
<p>虽然在严格意义上是正确的，但这肯定不完整-它表明<em>beforefieldinit</em>标志只会让初始化延迟，而不是提前。</p>
<p>值得注意的是，与v1和v2相比，v4 CLR的表现是不同-它们都符合规范，但是v4 CLR在很多情况下是真正的延迟，早期版本却会更急切。</p>
<h2 id="该怎么做呢"><a class="markdownIt-Anchor" href="#该怎么做呢"></a> 该怎么做呢？</h2>
<p>我提出以下修改意见：</p>
<ul>
<li>静态字段初始化器应该被视为静态构造函数的一部分。换句话说，任何具有静态初始化器或显式静态构造函数的类型都不应该（默认情况下）被标记为beforefieldinit。(对C#语言规范的修改。)</li>
<li>在代码中应该有一种方法可以覆盖这种默认行为。添加一个属性将是一个非常合理的解决方案。(修改C#语言规范，在标准库中增加一个属性。)</li>
<li><code>TypeAttributes.BeforeFieldInit</code>的文档应当对其行为描述清晰。(对MSDN文件和ECMA 335的修改)</li>
</ul>
<p>以上改动都是完全向后兼容的，不需要修改CLI。</p>
<h2 id="进一步的想法在与新闻组讨论后"><a class="markdownIt-Anchor" href="#进一步的想法在与新闻组讨论后"></a> 进一步的想法（在与新闻组讨论后）</h2>
<p>上述建议中，第一个建议肯定是最有争议的。(据我所知，最后一项根本没有争议)。原因是性能问题。其实没有多少类需要C#程序员去做这种假设的行为-事实上大多数人永远都不需要知道其中的区别。然而，JIT编译器会十分在意：比如说，如果在一个相当频繁的循环中使用了静态成员，那么在进入循环前就初始化类型是很有意义的，这样之后就知道类型已经初始化了。当代码在应用、作用域之间共享时，我认为这一点这会变得更重要。</p>
<p>使用新版本框架重新编译现有代码导致性能下降，无疑是不受欢迎的。因此，我愿意为此不太理想的建议让步-事实上，我只是处于历史的考虑，才把它留在这一页（我不喜欢做修正主义者）。</p>
<p>不过，第二个建议还是很重要的-既可以让明确需要静态构造函数的类在适当情况下使用BeforeFieldInit语义提高性能，也可以让目前只需要静态构造函数的类摆脱BeforeFieldInit语义，以更自我记录的方式达到目的。（一个初级开发人员更有可能删除一个看似没有操作的静态构造函数，而不是删除一个他们不完全理解的属性。）</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/BeforeFieldInit">C# and beforefieldinit</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><em>个人理解：类型初始化器是指普通的构造函数，这里与静态构造函数作区分</em> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>翻译</tag>
        <tag>beforefieldinit</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2021/01/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>. <span id="more"></span></p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中MeshColldier问题记录</title>
    <url>/2022/08/12/Mesh-Collider-Problem/</url>
    <content><![CDATA[<p>最近在工作的时候碰到了一个关于MeshCollider的问题，情况是这样的：需求是在游戏中存在一个绕自身Y轴旋转的三角形障碍，类似下图：<br/><br />
<img src="/image/Mesh/normal_rotate.gif" alt="Triangle" /><br/><br />
节点结构如下：<br/><br />
<img src="/image/Mesh/node.png" alt="Node" /><br/><br />
旋转脚本也很简单：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rotate</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> RotateSpeed;</span><br><span class="line">    <span class="keyword">public</span> RotateAxis RotateAxis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> axis = Vector3.zero;</span><br><span class="line">        <span class="keyword">switch</span> (RotateAxis)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> RotateAxis.Up:</span><br><span class="line">                axis = Vector3.up;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RotateAxis.Forward:</span><br><span class="line">                axis = Vector3.forward;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RotateAxis.Right:</span><br><span class="line">                axis = Vector3.right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        transform.Rotate(axis, Time.deltaTime * RotateSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> RotateAxis</span><br><span class="line">&#123;</span><br><span class="line">    Up,</span><br><span class="line">    Forward,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际情况要复杂一些，但是核心需求就是如此，神奇的是在实际运行后，发现MeshCollider和MeshRender在旋转时会出现有规律的<strong>错位</strong>，如下图：<br/><br />
<img src="/image/Mesh/wrong_rotate.gif" alt="Triangle" /><br/><br />
实际情况下没这么夸张的错位，但是还是比较明显的。当时十分费解，首先怀疑是旋转脚本的问题，把旋转逻辑从Update里转移到了协程里，发现还是有问题，又尝试使用DoTween动画去做，和料想的一样，依旧没有解决问题，<br />
然后又尝试新建场景，进行尝试，使用相同的MeshCollider和MeshRender，发现错位问题没有了。。。😟<br/><br />
秉持着遇事不决查文档的态度，果断打开了官方文档<a href="https://docs.unity3d.com/Manual/class-MeshCollider.html">MeshCollider</a>，看了半天没什么发现，那就只能开始大海捞针，寻找“志同道合”的朋友。<br />
结果还真让我找到了<a href="https://gamedev.stackexchange.com/questions/63428/unity-mesh-and-collider-not-aligned-on-rotation">“志同道合”的朋友</a>，恍然大悟，究其原因，是因为<strong>当MeshCollider作为子节点时，其上层父节如果存在缩放</strong>，那么此时对Collider进行旋转就会出现错位的现象，之后自己又进行了尝试，发现将Collider节点设置如下情况：<br/><br />
<img src="/image/Mesh/wrong_node.png" alt="WrongNode" /><br/><br />
将其父节点设置为：<br/><br />
<img src="/image/Mesh/wrong_node1.png" alt="WrongNode" /><br/><br />
就会出现旋转错位，总结一下就是：<br><br />
对MeshCollider进行旋转时，当其父节点存在<strong>对非旋转轴方向的缩放</strong>时，就会出现与MeshRender<strong>错位</strong>的现象，如上述情况，绕Y轴旋转，父节点存在X或Z轴缩放时，就会出现错位。<br/></p>
<p>找到了问题，就要解决问题了，按理来说，父节点不要缩放就可以了，但是实际情况是，父节点下有多个其他相关功能的节点，调整父节点缩放会影响其他子节点的显示，因为当时观察的时候发现，其实错位的时机是由规律可循的，也就是说每转一圈，两者是有重合的时刻的，并且与转了多少圈没有关系，结果试了半天，也没找到啥规律，所有放弃了，官方也没说是什么原因或者原理造成的，也没解决方案，但是庆幸的是经过高人指点，使用了一个非常之Trick的方法解决了这个问题：<strong>在Update里失效再激活MeshCollider组件</strong>，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rotate</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> RotateSpeed;</span><br><span class="line">    <span class="keyword">public</span> RotateAxis RotateAxis;</span><br><span class="line">    <span class="keyword">public</span> MeshCollider Collider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Collider.enabled = <span class="literal">false</span>;</span><br><span class="line">        Collider.enabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> axis = Vector3.zero;</span><br><span class="line">        <span class="keyword">switch</span> (RotateAxis)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> RotateAxis.Up:</span><br><span class="line">                axis = Vector3.up;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RotateAxis.Forward:</span><br><span class="line">                axis = Vector3.forward;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RotateAxis.Right:</span><br><span class="line">                axis = Vector3.right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        transform.Rotate(axis, Time.deltaTime * RotateSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> RotateAxis</span><br><span class="line">&#123;</span><br><span class="line">    Up,</span><br><span class="line">    Forward,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，该问题得到了不太完美的解决，回头再看官方文档时，发现其实文档里是有说明这种情况：<br/><br />
<img src="/image/Mesh/result.png" alt="Result" /><br/><br />
还是太不仔细了呀！绕了这么一大圈，所以在此记录以供警示！⚠️</p>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>问题记录</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode调试相关问题</title>
    <url>/2024/01/23/Debugging-Unicode-Problems/</url>
    <content><![CDATA[<p>本文用于指导在一些特殊情况下该如何做。也就是，您在某处（通常是数据库）有一些字符数据，这些数据需要经过几个步骤，最终显示给用户（通常在网页上）。不幸的是，有些字符会显示异常。由于涉及多个步骤，问题可能出现在多个地方。本文旨在帮助您简单、可靠地找出问题所在。</p>
<h2 id="第一步了解unicode的基础知识"><a class="markdownIt-Anchor" href="#第一步了解unicode的基础知识"></a> 第一步：了解Unicode的基础知识</h2>
<p>如果您对Unicode、字符编码等能熟练掌握，那么可以跳过这一步。一般来说，在进一步深入之前，您需要了解一些关于字符是什么，以及字符可以进行哪些转换的知识。更多信息请参见我关于此主题的文章(<a href="https://csharpindepth.com/articles/Unicode">原文</a> <a href="/2021/01/21/Unicode">译文</a>)（以及它引用的文章）。</p>
<h2 id="第二步尝试识别可能涉及的转换"><a class="markdownIt-Anchor" href="#第二步尝试识别可能涉及的转换"></a> 第二步：尝试识别可能涉及的转换</h2>
<p>如果您能弄清楚问题<em>可能</em>出在哪里，就更容易分辨出具体是哪里出了问题。同时不仅要考虑到您如何检索数据的，还要考虑数据最初是如何存入的。（我见过的一些问题是由于旧应用程序以错误的方式向数据库写入和读取数据，导致错误相互抵消了。只有这个有问题的应用程序访问数据库时不会出现问题，但任何其他东西访问数据库时，就都会出错。）涉及到的步骤可能包括从数据库获取数据、从文件中读取数据、通过网络连接发送数据或在屏幕上显示数据。</p>
<h2 id="第三步验证每一步的数据"><a class="markdownIt-Anchor" href="#第三步验证每一步的数据"></a> 第三步：验证每一步的数据</h2>
<p>首先不要信任任何试图将字符数据作为一系列的字形（glyphs）进行记录并输出的东西。相反，您应该将字符数据记录为一系列的Unicode值（整数）。例如，如果我有一个包含单词 “hello” 的字符串，我会将其显示为 “0068 0065 006c 006c 006f”。（使用十六进制可以让您在稍后检查Unicode代码图表时更容易进行比对。）要做到这一点，请逐个检查字符串中的每个字符，并以显示整数的方式显示该字符。例如，这是一个将字符串中所有字符输出到控制台的方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DumpString</span> (<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> <span class="keyword">value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#123;0:x4&#125; &quot;</span>, (<span class="built_in">int</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据您的具体环境，输出方法会有所不同，但使用类似上述的方法应该能为您提供所需的信息。我的关于字符串的文章提供了更详细的调试形式。</p>
<p>这样做的目的是为了排除字体、其他编码问题等方面的原因。如果您连普通的ASCII十六进制数字都无法正确输出，那您就遇到大麻烦了——您可能无法以可靠的方式输出Unicode，而且您已经知道了问题出在了Unicode，所以必须采取一些安全措施。</p>
<p>现在您需要确保有一个测试案例可以使用。找到您的应用程序出错的某个（最好是个小型的）示例，确保您知道正确的结果应该是什么，然后在您可能遇到问题的每个点都输出实际结果。（有些可能不在您的控制范围内，但通常如果您在接收到某些数据后立即输出，并在发送某些数据之前输出，您就能找到问题所在了。）</p>
<p>输出了有问题的字符串后，您应该验证它是否是正确的形式。这就是<a href="https://www.unicode.org/charts/">Unicode代码图表</a>的用处所在了。您可以选择您认为正确字符所在的部分，或者可以按字母顺序搜索您的字符。检查字符串中的每个字符的Unicode值是否正确。一旦您在应用程序流程中发现了字符数据被损坏的点，您应该检查该代码区域，找出字符被损坏的原因并修复它。当您在整个应用程序流程中都检查无误后，应用程序应该就能正常工作了。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>像软件工程中的许多问题一样，解决文本问题通常会使用“分而治之”的方法。当您对每个步骤都有信心时，您应该就会对整体充满信心。如果您在解决问题时遇到特别棘手的情况，我强烈建议您编写包含这些情况的单元测试——既可以作为可能发生的事情的文档，也可以作为防止未来回归的预防措施。</p>
<blockquote>
<p>本文是对<a href="https://csharpindepth.com/articles/DebuggingUnicode">Debugging Unicode Problems</a>这篇文章的翻译，作者是著有<a href="https://csharpindepth.com/">C# in Depth</a>的大神<a href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>翻译</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
</search>
