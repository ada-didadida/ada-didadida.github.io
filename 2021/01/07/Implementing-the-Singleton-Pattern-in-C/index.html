<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.svg">
  <link rel="mask-icon" href="/images/favicon-512x512.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="介绍 单例模式是软件工程中最为人熟知的一种设计模式。本质上讲，单例就是一个类，这个类只允许创建一个自己的实例，并且通常会提供一个对该实例的简单访问。最常见的情况是，单例在实例化时不允许指定任何参数，否则的话，在第二次请求时，如果使用不同的参数，就会出现问题！（如果所有带有相同参数的请求都会访问相同的实例，那么工厂模式会比较合适）本文只涉及不需要参数的情况。通常情况下，对单例创建的要求是延迟（L">
<meta property="og:type" content="article">
<meta property="og:title" content="单例模式在C#中的实现">
<meta property="og:url" content="http://example.com/2021/01/07/Implementing-the-Singleton-Pattern-in-C/index.html">
<meta property="og:site_name" content="ada-didadida的博客">
<meta property="og:description" content="介绍 单例模式是软件工程中最为人熟知的一种设计模式。本质上讲，单例就是一个类，这个类只允许创建一个自己的实例，并且通常会提供一个对该实例的简单访问。最常见的情况是，单例在实例化时不允许指定任何参数，否则的话，在第二次请求时，如果使用不同的参数，就会出现问题！（如果所有带有相同参数的请求都会访问相同的实例，那么工厂模式会比较合适）本文只涉及不需要参数的情况。通常情况下，对单例创建的要求是延迟（L">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-07T06:23:24.000Z">
<meta property="article:modified_time" content="2022-08-05T06:29:05.578Z">
<meta property="article:author" content="ada-didadida">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="Singleton">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/01/07/Implementing-the-Singleton-Pattern-in-C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/01/07/Implementing-the-Singleton-Pattern-in-C/","path":"2021/01/07/Implementing-the-Singleton-Pattern-in-C/","title":"单例模式在C#中的实现"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>单例模式在C#中的实现 | ada-didadida的博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?5adfd765dfcbf465251dea0a22e5dafb"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ada-didadida的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">12</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text"> 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%B8%80-%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">2.</span> <span class="nav-text"> 版本一 - 非线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%BA%8C-%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.</span> <span class="nav-text"> 版本二 - 简单的线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%B8%89-%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E5%8F%8C%E9%87%8D%E9%94%81%E4%BF%9D%E8%AF%81%E7%BA%BF%E6%80%A7%E5%AE%89%E5%85%A8"><span class="nav-number">4.</span> <span class="nav-text"> 版本三 - 尝试使用双重锁保证线性安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%9B%9B-%E4%B8%8D%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F%E4%BD%86%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%B2%A1%E6%9C%89%E7%94%A8%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text"> 版本四 - 不是典型的懒惰模式但线程安全没有用锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%BA%94-%E5%AE%8C%E5%85%A8%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text"> 版本五 - 完全延迟加载实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%85%AD-%E4%BD%BF%E7%94%A8net4%E7%9A%84lazyt%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text"> 版本六 - 使用.NET4的Lazy类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BB%B6%E8%BF%9Flaziness"><span class="nav-number">8.</span> <span class="nav-text"> 性能与延迟（Laziness）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">9.</span> <span class="nav-text"> 异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">10.</span> <span class="nav-text"> 结论</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ada-didadida"
      src="/images/portrait.gif">
  <p class="site-author-name" itemprop="name">ada-didadida</p>
  <div class="site-description" itemprop="description">记录碰到的技术问题<br/>翻译偶遇的国外大神文章</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ada-didadida" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ada-didadida" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:djy940214@gmail.com" title="E-Mail → mailto:djy940214@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/92462594" title="哔哩哔哩 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;92462594" rel="noopener" target="_blank"><i class="fa fa-tv fa-fw"></i>哔哩哔哩</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/07/Implementing-the-Singleton-Pattern-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portrait.gif">
      <meta itemprop="name" content="ada-didadida">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ada-didadida的博客">
      <meta itemprop="description" content="记录碰到的技术问题<br/>翻译偶遇的国外大神文章">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="单例模式在C#中的实现 | ada-didadida的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          单例模式在C#中的实现
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-07 14:23:24" itemprop="dateCreated datePublished" datetime="2021-01-07T14:23:24+08:00">2021-01-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-05 14:29:05" itemprop="dateModified" datetime="2022-08-05T14:29:05+08:00">2022-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C#</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <!-- # 目录
  - [介绍](#介绍)
  - [版本一&nbsp;-&nbsp;非线程安全](#版本一-非线程安全)
  - [版本二&nbsp;-&nbsp;简单的线程安全](#版本二-简单的线程安全)
  - [版本三&nbsp;-&nbsp;尝试使用双重锁保证线性安全](#版本三-尝试使用双重锁保证线性安全)
  - [版本四&nbsp;-&nbsp;不是典型的懒惰模式但线程安全没有用锁](#版本四-不是典型的懒惰模式但线程安全没有用锁)
  - [版本五&nbsp;-&nbsp;完全延迟加载实现](#版本五-完全延迟加载实现)
  - [版本六&nbsp;-&nbsp;使用\.NET4的Lazy<T>类型](#版本六-使用net4的lazyt类型)
  - [性能与延迟\（Laziness\）](#性能与延迟laziness)
  - [异常](#异常)
  - [结论](#结论) -->
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>单例模式是软件工程中最为人熟知的一种设计模式。本质上讲，单例就是一个类，这个类只允许创建一个自己的实例，并且通常会提供一个对该实例的简单访问。最常见的情况是，单例在实例化时不允许指定任何参数，否则的话，在第二次请求时，如果使用不同的参数，就会出现问题！（如果所有带有相同参数的请求都会访问相同的实例，那么工厂模式会比较合适）本文只涉及不需要参数的情况。通常情况下，对单例创建的要求是延迟（Lazy）创建-即在第一次需要之前不会创建实例。 <span id="more"></span></p>
<p>在C#中，有多种不同的方式来实现单例模式。我会按照由浅入深顺序介绍，从最常见的、非线程安全的版本开始，一直到完全延迟加载、线性安全、简单且高性能的版本。</p>
<p>然而，所有实现方式都有四个功能特点：</p>
<ul>
<li>一个单一的私有无参构造函数，以防止其他类对其进行实例化（违反了单例模式）。请注意，这还能防止子类继承-如果一个单例能够被子类化一次，那么肯定可以子类化两次，那么每个子类都可以创建一个实例，显然违反了单例模式。如果你需要一个基类的单例，在运行前并不知道确切的类型，那么可以使用工厂模式。</li>
<li>单例类是密封类（sealed），严格来说，由于上面一条的限制，这一点完全没必要，但这可能会帮助JIT进行优化。</li>
<li>一个静态变量，如果存在的话，他持有单例创建出的实例的引用。</li>
<li>一个静态方法，用于获取单例实例的引用，必要时，需要创建实例。<em>个人理解：实例存在则获取，不存在则创建</em></li>
</ul>
<p>请注意，所有实现方式都要使用静态公共属性<code>Instance</code>作为访问实例的途径。在任何情况下，该属性都应该可以很容易的转换为一个方法，而不会对线程安全或性能造成影响。</p>
<h2 id="版本一-非线程安全"><a class="markdownIt-Anchor" href="#版本一-非线程安全"></a> 版本一 - 非线程安全</h2>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的代码！不用使用！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前已经提过，上面的版本是非线程安全的。两个不同的线程有可能对 <code>if (instance == null)</code> 都判断为true，然后都创建了实例，这就违反了单例模式。请注意，其实在判断if表达式之前，实例可能就已经被创建了，但内存无法保证新创建的实例能被其他线程看到，除非有一道合适的内存壁垒（memory barrier）来保证这一点。<em>个人理解：所谓合适的内存壁垒应该是指线程锁-lock</em></p>
<h2 id="版本二-简单的线程安全"><a class="markdownIt-Anchor" href="#版本二-简单的线程安全"></a> 版本二 - 简单的线程安全</h2>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> padlock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (padlock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方式是线程安全的。线程会取出共享对象的锁（lock），然后再去在创建实例前检查实例是否已经创建。这样就解决了内存壁垒（memory barrier）的问题（因为锁定操作确保了所有的读取操作在逻辑上都发生在获取锁之后，而解锁操作确保了所有的写入操作在逻辑上都发生在释放锁之前），并确保只有一个线程会创建一个实例（因为一次只能有一个线程进入这部分代码–当第二个线程进入的时候，第一个线程已经创建了实例，对if表达式的判断为false）。不幸的是，由于每次请求实例时都会有一个获取锁的过程，导致性能会受到影响。</p>
<p>请注意，我没有像某些版本的实现那样，锁定<code>typeof(Singleton)</code>，而是锁定了一个私有的静态变量。锁定一个其他类可以访问的对象（比如Type），有可能会出现性能问题，甚至是死锁（deadlocks）。我一般会偏爱这种风格–在可能的情况下，创建专门用于锁定的对象，只锁定该对象，或者为了特定的目的而锁定文件（document）（例如：用于等待/pulsing一个队列）。通常这样的对象应该是它所在类的私有对象。这样更易于编写线程安全的应用。</p>
<h2 id="版本三-尝试使用双重锁保证线性安全"><a class="markdownIt-Anchor" href="#版本三-尝试使用双重锁保证线性安全"></a> 版本三 - 尝试使用双重锁保证线性安全</h2>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的代码！不用使用！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> padlock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (padlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式试图在做到线程安全的同时不用每次都获取锁（lock）。不幸的是，这种模式有四个缺点：</p>
<ul>
<li>这在Java中不起作用。这或许很奇怪，但是如果你在Java中也需要用到单例的话，还是有必要了解一下，毕竟C#程序员也有可能是Java程序员。Java内存模型并不能保证新对象的引用在被分配给实例之前，构造函数就已经完成了。Java内存模型在1.5版本进行了重构，但是在这之后，如果没有易失性变量（volatile variable），双重检查锁还是会被破坏（和C#一样）。</li>
<li>在没有任何内存壁垒（线程锁）的情况下，它也打破了ECMA CLI规范。在 .NET 2.0的内存模型下（比ECMA规范更强） 有可能是安全的，但我宁愿依赖那些更强的语义，尤其是对安全性存在怀疑的情况下。让实例变量变得不稳定（volatile）可以使其正常运转，显式的内存壁垒调用也可以正常运行，尽管在后一种情况下，即使专家也无法统一到底需要什么样的壁垒。我倾向于避免出现专家都在争论对错的情况！</li>
<li>很容易出错。这种模式和上一种模式差不多–出现任何重大变化都有可能影响其性能或正确性。</li>
<li>它的性能还是不如之后的实现。</li>
</ul>
<h2 id="版本四-不是典型的懒惰模式但线程安全没有用锁"><a class="markdownIt-Anchor" href="#版本四-不是典型的懒惰模式但线程安全没有用锁"></a> 版本四 - 不是典型的懒惰模式但线程安全没有用锁</h2>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过显示的静态构造函数告诉C#编译器</span></span><br><span class="line">    <span class="comment">// 不要将类型标记为beforfieldinit</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，这真的是极其简单–但为什么它是线性安全的？又是如何做到延迟处理（lazy）的呢？在C#中静态构造函数被指定为只有在类的实例被创建或静态成员被引用时才执行，并且每个AppDomain只执行一次。考虑到对类型的新构造无论如何都会执行，这将比之前的添加额外检查的例子执行的更快。不过，还是存在一些小缺点：</p>
<ul>
<li>它不像其他实现那么地延迟（lazy）。特别是，如果存在<code>Instance</code>以外的静态成员，那么对这些成员的第一次引用将会导致创建实例。</li>
<li>会有一种复杂的情况：一个静态构造函数调用了另一个静态构造函数，另一个又调用了第一个（<em>个人理解：两个静态构造函数相互调用</em>）。可以在.Net规范中（9.5.3节的partition Ⅱ）查看更多关于类型初始化器的细节–别担心，不会太难，但需要注意在循环中静态构造函数互相引用的后果。</li>
<li>只有当类型被特殊标记为<code>beforefieldinit</code>时，.Net才会保证类型初始器的延迟性（laziness）。不幸的是，C#编译器（至少在 .Net 1.1的运行时）会将所有没有静态构造函数的类型（即被标记为静态的构造函数）标记为<code>beforefieldinit</code>。我这里有一篇文章（<a target="_blank" rel="noopener" href="https://csharpindepth.com/articles/BeforeFieldInit">原文</a> <a href="/2021/01/11/beforefieldinit/index.html">译文</a>），详细介绍了这个问题。另外请注意，这会对性能造成影响，这一点会在文末进行讨论。</li>
</ul>
<p>对于这个实现方式（也只有这个方式），可以采取一种快捷方式，就是直接把<code>instance</code>作为只读的公共静态变量，然后抛弃<code>Instance</code>属性。这样能使代码的基本骨架更小巧。但大多数人还是希望有一个属性，以便于后续添加进一步的操作，并且JIT内联很可能使性能相同。（注意，如果需要延迟性，静态构造函数还是需要的）</p>
<h2 id="版本五-完全延迟加载实现"><a class="markdownIt-Anchor" href="#版本五-完全延迟加载实现"></a> 版本五 - 完全延迟加载实现</h2>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> Nested.instance; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Nested</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过显示的静态构造函数告诉C#编译器</span></span><br><span class="line">        <span class="comment">// 不要将类型标记为beforfieldinit</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">Nested</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式实例化是由嵌套类的静态成员首次引用触发的，只会发生在<code>Instance</code>调用中。这意味着实现了完全的延迟性，却保留了之前所有的性能优势。需要注意的是，虽然嵌套类可以访问包围类的私有成员，但反之则不行，因此需要将<code>instance</code>声明为internal。不过这不会引发其他问题，因为嵌套类本身是私有的。不过，为了让实例化延迟，代码会比较复杂。</p>
<h2 id="版本六-使用net4的lazyt类型"><a class="markdownIt-Anchor" href="#版本六-使用net4的lazyt类型"></a> 版本六 - 使用.NET4的Lazy<T>类型</h2>
<p>如果你使用的是 .Net 4（或更高版本），你可以使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1">System.Lazy<T></a> 类型让延迟（lazy）变得非常简单。你需要做的就是向调用Singleton构造函数的构造函数传递一个委托（delegate）–可以通过lambda表达式很容易地做到。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;Singleton&gt; lazy = <span class="keyword">new</span> Lazy&lt;Singleton&gt;(() =&gt; <span class="keyword">new</span> Singleton());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> lazy.Value; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这很简单，性能也不错。如果需要的话，你可以使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1.isvaluecreated">IsValueCreated</a>属性检查实例是否被创建。</p>
<p>上面的代码隐式使用了<code>LazyThreadSafetyMode.ExecutionAndPublication</code>作为<code>Lazy&lt;Singleton&gt;</code>的线程安全模式。你也可以根据自己的需求尝试其他模式。如果你的单例在一个相对频繁的循环中被引用，那么这样会是性能产生（相对）显著的差异。你需要决定是否需要完全延迟处理实例化，在类中的适当位置雅瑶记录这个决定。</p>
<h2 id="性能与延迟laziness"><a class="markdownIt-Anchor" href="#性能与延迟laziness"></a> 性能与延迟（Laziness）</h2>
<p>大多是情况下，实际上你并不需要完全的延迟处理–除非你在类初始化时做了一些特别耗时的操作，或者在别处做了一些有副作用的操作，否则不使用上文提到的显式静态构造函数也是可以的。这样可以提高性能，因为它允许JIT编译器进行一次简单的检查（例如在方法开始时），以确保类型已经被初始化，然后才开始使用它。</p>
<p>这一页之所以存在，很大程度上是大家自作聪明，想要想出一种双重锁检查的算法。有一个常见的误区，认为锁定（locking）是代价很大的操作。我有写过一个性能测试，它尝试用十亿种方式使用不同的变量在循环中获取单例。这样不是很科学，因为在现实中，你可能想知道，调用单例的方法在每次迭代中到底执行的有多快。不过，这确实说明了一个很重要的问题。在我的笔记本电脑上，最慢的解决方案（慢了有5倍）是使用锁定的那一个（方案2）。这一点重要吗？或许并不，你要知道，即使如此它仍然能在40秒内获取十亿次单例。（注：这篇文章距今已经有些时间了–我希望现在能有很好的表现）。这意味着，如果你每秒“只”获取四十万次单例，那么获取的成本只占性能的1%–所以提升它没太大用。现在，如果你要频繁的获取单例–是不是可以在循环中使用了？如果你那么在乎提高这一点性能，为何不在循环外声明一个局部变量，获取一次单例，再执行循环呢？对啦，这样即使最慢的实现也会变得轻松。</p>
<p>我非常乐意看到，在一个真实的应用中，使用简单锁定和使用更快方案之间，确实产生了显著的性能差异。</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p>有的时候，你需要在单例的构造函数中做一个工作，这有可能会造成异常，但可能对整个应用不会带来致命的影响。有可能，你的应用能够修复这个问题，然后想再尝试一次。在这个阶段使用类型初始化器来构造单例就会出现问题。不同的运行时对这种情况会有不同的处理，但我不知道那种运行时会做所需的事（再次运行类型初始化器），即使有，你的代码在别的运行时也可能被破坏。为了避免这个问题，我建议使用上页的第二种模式–只需要一个简单的锁，每次都检查一下，如果没有成功构建实例，就在方法/属性中构建实例。</p>
<p>感谢Andriy Tereshchenko提出这个问题。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>2006年1月7日略有修改；2011年2月12日更新</p>
<p>C#中有很多种实现单例模式的方法。有读者写信给我，详细介绍了他封装同步的方法，我承认这种方法可能在一些特殊情况下很有用（特别是你想要高性能，并且能够明确是否创建的单例，以及不管其他静态成员是够被调用都要延迟处理）。但我个人认为这种情况并不常出现，不值得在文章中继续讨论，但如果你碰到了这种情况，请给我<a href="mailto:skeet@pobox.com">发邮件</a>。（<em>原文作者邮箱</em>）</p>
<p>我个人更倾向于方案4，我只会在下面的情况下抛弃方案4：如果我需要在不触发初始化的情况下调用其他静态方法，或者我需要知道单例是否实例化。我不记得上次遇到这种情况是什么时候了，假如我碰到了，我可能会选择方案2，方案2还是不错的，很容易就能搞定。</p>
<p>方案5很优雅，但比方案2和方案4棘手，正如我上面所说，它的优势没那么有用。方案6是一种比较简单的实现延迟的方法，如果你使用的是 .Net 4，它的优势就是显著的延迟处理。目前，仅仅出于个人习惯，我仍然倾向于使用方案4–但是如果我是和没有开发经验的开发人员一起工作，我可能会选择方案6，因为这是一个简单且普遍使用的模式。</p>
<p>（我不会用方案1，因为它不完善，我也不会用方案3，因为它的优势没有方案5显著）</p>
<blockquote>
<p>本文是对<a target="_blank" rel="noopener" href="https://csharpindepth.com/articles/Singleton">Implementing the Singleton Pattern in C#</a>这篇文章的翻译，作者是著有<a target="_blank" rel="noopener" href="https://csharpindepth.com/">C# in Depth</a>的大神<a target="_blank" rel="noopener" href="https://jonskeet.uk/">Jon Skeet</a>。非文章原文或本人对某段文字理解，会以斜体 <em>个人理解：xxx</em> 进行标注。本人翻译能力有限，强烈建议大家去看原版！</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="ada-didadida 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="ada-didadida 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C#</a>
              <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"># 翻译</a>
              <a href="/tags/Singleton/" rel="tag"># Singleton</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/06/Markdown/" rel="prev" title="Markdown功能记录">
                  <i class="fa fa-chevron-left"></i> Markdown功能记录
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/11/beforefieldinit/" rel="next" title="C#和beforefieldinit属性">
                  C#和beforefieldinit属性 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ada-didadida</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
​
  <script color="0, 0, 0" 
          opacity="0.7" 
          zIndex="-1" 
          count="120" 
          src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js">
  </script>
​
  

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"ada-didadida","repo":"ada-didadida.github.io","client_id":"80f749eca3876a7e30b8","client_secret":"5f82cea2accf2940b0e81d328dc0e76060f7f8f1","admin_user":"ada-didadida","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d237f15f87215beb1141d75dc22bdc98"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
